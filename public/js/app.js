/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var sparticles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sparticles */ \"./node_modules/.pnpm/sparticles@1.3.1/node_modules/sparticles/dist/sparticles.mjs\");\n/* harmony import */ var count_it_down__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! count-it-down */ \"./node_modules/.pnpm/count-it-down@1.0.0/node_modules/count-it-down/dist/count-it-down.umd.js\");\n/* harmony import */ var count_it_down__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(count_it_down__WEBPACK_IMPORTED_MODULE_1__);\n\n\nnew sparticles__WEBPACK_IMPORTED_MODULE_0__[\"default\"](document.querySelector('.landing'), {\n  'composition': 'source-over',\n  'count': 400,\n  'speed': 0.1,\n  'parallax': 3,\n  'direction': 0,\n  'xVariance': 150,\n  'yVariance': 100,\n  'rotate': true,\n  'rotation': 1,\n  'alphaSpeed': 5,\n  'alphaVariance': 1,\n  'minAlpha': 0,\n  'maxAlpha': 0.5,\n  'minSize': 1,\n  'maxSize': 8,\n  'style': 'fill',\n  'bounce': false,\n  'drift': 1.6,\n  'glow': 14,\n  'twinkle': true,\n  'color': ['#be0818', '#e18814'],\n  'shape': 'diamond',\n  'imageUrl': ''\n});\n(function textEffect() {\n  var $textEffect = document.querySelector('[x-target=\"letter-effect\"]');\n  if (!$textEffect) return;\n  var toInnerSpan = function toInnerSpan(el) {\n    return el === ' ' ? ' ' : \"<span class=\\\"letter-effect__element\\\">\".concat(el, \"</span>\");\n  };\n  $textEffect.innerHTML = $textEffect.innerHTML.split('').map(toInnerSpan).join('');\n})();\n(function countdownToLotus() {\n  var lotusDate = new Date(2023, 2, 14, 19, 0, 0, 0);\n  var $countdown = document.querySelector('[x-target=\"countdown\"]');\n\n  // countItDown(lotusDate, ({ days, hours, minutes, seconds }) => {\n  //     $countdown.innerHTML = `\n  //         <span class=\"countdown__element\">${days}</span>\n  //         <span class=\"countdown__element\">${hours}</span>\n  //         <span class=\"countdown__element\">${minutes}</span>\n  //         <span class=\"countdown__element\">${seconds}</span>\n  //     `.trim()\n  // })\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYXBwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBbUM7QUFDSTtBQUV2QyxJQUFJQSxrREFBVSxDQUFDRSxRQUFRLENBQUNDLGFBQWEsQ0FBQyxVQUFVLENBQUMsRUFDN0M7RUFDSSxhQUFhLEVBQUUsYUFBYTtFQUM1QixPQUFPLEVBQUUsR0FBRztFQUNaLE9BQU8sRUFBRSxHQUFHO0VBQ1osVUFBVSxFQUFFLENBQUM7RUFDYixXQUFXLEVBQUUsQ0FBQztFQUNkLFdBQVcsRUFBRSxHQUFHO0VBQ2hCLFdBQVcsRUFBRSxHQUFHO0VBQ2hCLFFBQVEsRUFBRSxJQUFJO0VBQ2QsVUFBVSxFQUFFLENBQUM7RUFDYixZQUFZLEVBQUUsQ0FBQztFQUNmLGVBQWUsRUFBRSxDQUFDO0VBQ2xCLFVBQVUsRUFBRSxDQUFDO0VBQ2IsVUFBVSxFQUFFLEdBQUc7RUFDZixTQUFTLEVBQUUsQ0FBQztFQUNaLFNBQVMsRUFBRSxDQUFDO0VBQ1osT0FBTyxFQUFFLE1BQU07RUFDZixRQUFRLEVBQUUsS0FBSztFQUNmLE9BQU8sRUFBRSxHQUFHO0VBQ1osTUFBTSxFQUFFLEVBQUU7RUFDVixTQUFTLEVBQUUsSUFBSTtFQUNmLE9BQU8sRUFBRSxDQUFDLFNBQVMsRUFDZixTQUFTLENBQUM7RUFDZCxPQUFPLEVBQUUsU0FBUztFQUNsQixVQUFVLEVBQUU7QUFDaEIsQ0FBQyxDQUFDO0FBRU4sQ0FBQyxTQUFTQyxVQUFVLEdBQUk7RUFDcEIsSUFBTUMsV0FBVyxHQUFHSCxRQUFRLENBQUNDLGFBQWEsQ0FBQyw0QkFBNEIsQ0FBQztFQUV4RSxJQUFJLENBQUNFLFdBQVcsRUFBRTtFQUVsQixJQUFNQyxXQUFXLEdBQUcsU0FBZEEsV0FBVyxDQUFHQyxFQUFFO0lBQUEsT0FBSUEsRUFBRSxLQUFLLEdBQUcsR0FBRyxHQUFHLG9EQUEyQ0EsRUFBRSxZQUFTO0VBQUE7RUFDaEdGLFdBQVcsQ0FBQ0csU0FBUyxHQUFHSCxXQUFXLENBQUNHLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDQyxHQUFHLENBQUNKLFdBQVcsQ0FBQyxDQUFDSyxJQUFJLENBQUMsRUFBRSxDQUFDO0FBQ3JGLENBQUMsR0FBRztBQUVKLENBQUMsU0FBU0MsZ0JBQWdCLEdBQUk7RUFFMUIsSUFBTUMsU0FBUyxHQUFHLElBQUlDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7RUFDcEQsSUFBTUMsVUFBVSxHQUFHYixRQUFRLENBQUNDLGFBQWEsQ0FBQyx3QkFBd0IsQ0FBQzs7RUFFbkU7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUVKLENBQUMsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9hcHAuanM/Y2VkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3BhcnRpY2xlcyBmcm9tICdzcGFydGljbGVzJ1xuaW1wb3J0IGNvdW50SXREb3duIGZyb20gJ2NvdW50LWl0LWRvd24nXG5cbm5ldyBTcGFydGljbGVzKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5sYW5kaW5nJyksXG4gICAge1xuICAgICAgICAnY29tcG9zaXRpb24nOiAnc291cmNlLW92ZXInLFxuICAgICAgICAnY291bnQnOiA0MDAsXG4gICAgICAgICdzcGVlZCc6IDAuMSxcbiAgICAgICAgJ3BhcmFsbGF4JzogMyxcbiAgICAgICAgJ2RpcmVjdGlvbic6IDAsXG4gICAgICAgICd4VmFyaWFuY2UnOiAxNTAsXG4gICAgICAgICd5VmFyaWFuY2UnOiAxMDAsXG4gICAgICAgICdyb3RhdGUnOiB0cnVlLFxuICAgICAgICAncm90YXRpb24nOiAxLFxuICAgICAgICAnYWxwaGFTcGVlZCc6IDUsXG4gICAgICAgICdhbHBoYVZhcmlhbmNlJzogMSxcbiAgICAgICAgJ21pbkFscGhhJzogMCxcbiAgICAgICAgJ21heEFscGhhJzogMC41LFxuICAgICAgICAnbWluU2l6ZSc6IDEsXG4gICAgICAgICdtYXhTaXplJzogOCxcbiAgICAgICAgJ3N0eWxlJzogJ2ZpbGwnLFxuICAgICAgICAnYm91bmNlJzogZmFsc2UsXG4gICAgICAgICdkcmlmdCc6IDEuNixcbiAgICAgICAgJ2dsb3cnOiAxNCxcbiAgICAgICAgJ3R3aW5rbGUnOiB0cnVlLFxuICAgICAgICAnY29sb3InOiBbJyNiZTA4MTgnLFxuICAgICAgICAgICAgJyNlMTg4MTQnXSxcbiAgICAgICAgJ3NoYXBlJzogJ2RpYW1vbmQnLFxuICAgICAgICAnaW1hZ2VVcmwnOiAnJ1xuICAgIH0pO1xuXG4oZnVuY3Rpb24gdGV4dEVmZmVjdCAoKSB7XG4gICAgY29uc3QgJHRleHRFZmZlY3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbeC10YXJnZXQ9XCJsZXR0ZXItZWZmZWN0XCJdJylcblxuICAgIGlmICghJHRleHRFZmZlY3QpIHJldHVyblxuXG4gICAgY29uc3QgdG9Jbm5lclNwYW4gPSBlbCA9PiBlbCA9PT0gJyAnID8gJyAnIDogYDxzcGFuIGNsYXNzPVwibGV0dGVyLWVmZmVjdF9fZWxlbWVudFwiPiR7ZWx9PC9zcGFuPmBcbiAgICAkdGV4dEVmZmVjdC5pbm5lckhUTUwgPSAkdGV4dEVmZmVjdC5pbm5lckhUTUwuc3BsaXQoJycpLm1hcCh0b0lubmVyU3Bhbikuam9pbignJylcbn0pKCk7XG5cbihmdW5jdGlvbiBjb3VudGRvd25Ub0xvdHVzICgpIHtcblxuICAgIGNvbnN0IGxvdHVzRGF0ZSA9IG5ldyBEYXRlKDIwMjMsIDIsIDE0LCAxOSwgMCwgMCwgMClcbiAgICBjb25zdCAkY291bnRkb3duID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW3gtdGFyZ2V0PVwiY291bnRkb3duXCJdJylcblxuICAgIC8vIGNvdW50SXREb3duKGxvdHVzRGF0ZSwgKHsgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMgfSkgPT4ge1xuICAgIC8vICAgICAkY291bnRkb3duLmlubmVySFRNTCA9IGBcbiAgICAvLyAgICAgICAgIDxzcGFuIGNsYXNzPVwiY291bnRkb3duX19lbGVtZW50XCI+JHtkYXlzfTwvc3Bhbj5cbiAgICAvLyAgICAgICAgIDxzcGFuIGNsYXNzPVwiY291bnRkb3duX19lbGVtZW50XCI+JHtob3Vyc308L3NwYW4+XG4gICAgLy8gICAgICAgICA8c3BhbiBjbGFzcz1cImNvdW50ZG93bl9fZWxlbWVudFwiPiR7bWludXRlc308L3NwYW4+XG4gICAgLy8gICAgICAgICA8c3BhbiBjbGFzcz1cImNvdW50ZG93bl9fZWxlbWVudFwiPiR7c2Vjb25kc308L3NwYW4+XG4gICAgLy8gICAgIGAudHJpbSgpXG4gICAgLy8gfSlcblxufSkoKTtcbiJdLCJuYW1lcyI6WyJTcGFydGljbGVzIiwiY291bnRJdERvd24iLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJ0ZXh0RWZmZWN0IiwiJHRleHRFZmZlY3QiLCJ0b0lubmVyU3BhbiIsImVsIiwiaW5uZXJIVE1MIiwic3BsaXQiLCJtYXAiLCJqb2luIiwiY291bnRkb3duVG9Mb3R1cyIsImxvdHVzRGF0ZSIsIkRhdGUiLCIkY291bnRkb3duIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/app.js\n");

/***/ }),

/***/ "./node_modules/.pnpm/count-it-down@1.0.0/node_modules/count-it-down/dist/count-it-down.umd.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/count-it-down@1.0.0/node_modules/count-it-down/dist/count-it-down.umd.js ***!
  \*****************************************************************************************************/
/***/ (function(module) {

eval("!function(e,t){ true?module.exports=t():0}(this,function(){return function(e,t){void 0===t&&(t=function(){});var n=e instanceof Date?e.getTime():new Date(e).getTime(),o=window.requestIdleCallback||function(e){return setTimeout(e,0)};return window.setInterval(function(){return o(function(){var e=(new Date).getTime(),o=n-e;t({days:Math.floor(o/864e5),hours:Math.floor(o%864e5/36e5),minutes:Math.floor(o%36e5/6e4),seconds:Math.floor(o%6e4/1e3)})})},1e3)}});\n//# sourceMappingURL=count-it-down.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vY291bnQtaXQtZG93bkAxLjAuMC9ub2RlX21vZHVsZXMvY291bnQtaXQtZG93bi9kaXN0L2NvdW50LWl0LWRvd24udW1kLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsS0FBb0Qsb0JBQW9CLENBQWlFLENBQUMsaUJBQWlCLHFCQUFxQiwyQkFBMkIsRUFBRSxvR0FBb0csd0JBQXdCLHFDQUFxQyxvQkFBb0IsaUNBQWlDLEdBQUcscUhBQXFILEVBQUUsRUFBRSxPQUFPO0FBQ3JqQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucG5wbS9jb3VudC1pdC1kb3duQDEuMC4wL25vZGVfbW9kdWxlcy9jb3VudC1pdC1kb3duL2Rpc3QvY291bnQtaXQtZG93bi51bWQuanM/ZmMxOCJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZSh0KTplLmNvdW50SXREb3duPXQoKX0odGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PWZ1bmN0aW9uKCl7fSk7dmFyIG49ZSBpbnN0YW5jZW9mIERhdGU/ZS5nZXRUaW1lKCk6bmV3IERhdGUoZSkuZ2V0VGltZSgpLG89d2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2t8fGZ1bmN0aW9uKGUpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9O3JldHVybiB3aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtyZXR1cm4gbyhmdW5jdGlvbigpe3ZhciBlPShuZXcgRGF0ZSkuZ2V0VGltZSgpLG89bi1lO3Qoe2RheXM6TWF0aC5mbG9vcihvLzg2NGU1KSxob3VyczpNYXRoLmZsb29yKG8lODY0ZTUvMzZlNSksbWludXRlczpNYXRoLmZsb29yKG8lMzZlNS82ZTQpLHNlY29uZHM6TWF0aC5mbG9vcihvJTZlNC8xZTMpfSl9KX0sMWUzKX19KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvdW50LWl0LWRvd24udW1kLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/count-it-down@1.0.0/node_modules/count-it-down/dist/count-it-down.umd.js\n");

/***/ }),

/***/ "./resources/css/app.scss":
/*!********************************!*\
  !*** ./resources/css/app.scss ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvY3NzL2FwcC5zY3NzLmpzIiwibWFwcGluZ3MiOiI7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9jc3MvYXBwLnNjc3M/NzYzYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/css/app.scss\n");

/***/ }),

/***/ "./node_modules/.pnpm/sparticles@1.3.1/node_modules/sparticles/dist/sparticles.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/sparticles@1.3.1/node_modules/sparticles/dist/sparticles.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**!\n * Sparticles - Lightweight, High Performance Particles in Canvas\n * @version 1.3.1\n * @license MPL-2.0\n * @author simeydotme <simey.me@gmail.com>\n * @website http://sparticlesjs.dev\n * @repository https://github.com/simeydotme/sparticles.git\n */\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n/**\n * Limited Animation Frame method, to allow running\n * a given handler at the maximum desired frame rate.\n * inspired from https://gist.github.com/addyosmani/5434533\n * @param {Function} handler method to execute upon every frame\n * @param {Number} fps how many frames to render every second\n */\nvar AnimationFrame = function AnimationFrame() {\n  var handler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n  var fps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;\n  this.fps = fps;\n  this.handler = handler;\n  var renderId = 0;\n  /**\n   * begin the animation loop which is assigned\n   * to the instance in the constructor\n   */\n\n  this.start = function () {\n    var _this = this;\n\n    if (!this.started) {\n      var then = performance.now();\n      var interval = 1000 / this.fps;\n      var tolerance = 0;\n\n      var loop = function loop(now) {\n        var delta = now - then;\n        renderId = requestAnimationFrame(loop);\n\n        if (delta >= interval - tolerance) {\n          _this.handler(delta);\n\n          then = now - delta % interval;\n        }\n      };\n\n      renderId = requestAnimationFrame(loop);\n      this.started = true;\n    }\n  };\n  /**\n   * stop the currently running animation loop\n   */\n\n\n  this.stop = function () {\n    cancelAnimationFrame(renderId);\n    this.started = false;\n  };\n};\n\n/**\n * return the cartesian x/y delta value from a degree\n * eg: 90 (→) = [1,0]\n * @param {Number} angle angle in degrees\n * @returns {Number[]} cartesian delta values\n */\nvar cartesian = function cartesian(angle) {\n  return [Math.cos(radian(angle - 90)), Math.sin(radian(angle - 90))];\n};\n/**\n * clamp the input number to the min/max values\n * @param {Number} value value to clamp between min and max\n * @param {Number} min minimum value possible\n * @param {Number} max maximum value possible\n * @returns {Number} the input num clamped between min/max\n */\n\nvar clamp = function clamp(value) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return Math.max(min, Math.min(max, value));\n};\n/**\n * return the radian equivalent to a degree value\n * @param {Number} angle angle in degrees\n * @returns {Number} radian equivalent\n */\n\nvar radian = function radian(angle) {\n  return angle * Math.PI / 180;\n};\n/**\n * return random number between a min and max value\n * @param {Number} min minimum value\n * @param {Number} max maximum value\n * @param {Boolean} rounded should the result be rounded\n * @returns {Number} a random number between min and max\n */\n\nvar random = function random() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Math.random();\n\n  if (max <= min) {\n    value = min;\n  } else if ((min !== 0 || max !== 1) && max > min) {\n    value = value * (max - min) + min;\n  }\n\n  return value;\n};\n/**\n * return a random value from an array\n * @param {Array} array an array to get random value from\n * @returns {*} random value from array\n */\n\nvar randomArray = function randomArray(array) {\n  return array[Math.floor(random(0, array.length))];\n};\n/**\n * return a random HSL colour string for use in random color effect\n * @returns {String} \"hsl(100,100,80)\"\n */\n\nvar randomHsl = function randomHsl() {\n  var h = round(random(0, 360));\n  var s = round(random(90, 100));\n  var l = round(random(45, 85));\n  return \"hsl(\".concat(h, \",\").concat(s, \"%,\").concat(l, \"%)\");\n};\n/**\n * return a boolean to pass a dice roll\n * @param {Number} odds a fraction to use as the probability, can be supplied as \"1/2\"\n * @returns {Boolean}\n */\n\nvar roll = function roll(odds) {\n  return odds > random();\n};\n/**\n * round a number to the nearest integer value\n * @param {Number} value value to round to the nearest integer\n * @returns {Number} nearest integer\n */\n\nvar round = function round(value) {\n  return 0.5 + value | 0;\n};\n\n/**\n * Sparticle Constructor;\n * creates an individual particle for use in the Sparticles() class\n * @param {Object} parent - the parent Sparticles() instance this belongs to\n * @returns {Object} - reference to a new Sparticle instance\n */\n\nvar Sparticle = function Sparticle(parent) {\n  if (parent) {\n    this.canvas = parent.canvas;\n    this.settings = parent.settings;\n    this.colors = parent.colors;\n    this.shapes = parent.shapes;\n    this.images = parent.images;\n    this.styles = parent.styles;\n    this.ctx = parent.canvas.getContext(\"2d\");\n    this.setup();\n    this.init();\n  } else {\n    console.warn(\"Invalid parameters given to Sparticle()\", arguments);\n  }\n\n  return this;\n};\n/**\n * set up the particle with some random values\n * before it is initialised on the canvas\n * these values will randomize when the particle goes offscreen\n */\n\nSparticle.prototype.setup = function () {\n  var _ = this.settings;\n  this.frame = 0;\n  this.frameoffset = round(random(0, 360));\n  this.size = round(random(_.minSize, _.maxSize));\n  this.da = this.getAlphaDelta();\n  this.dx = this.getDeltaX();\n  this.dy = this.getDeltaY();\n  this.dd = this.getDriftDelta();\n  this.dr = this.getRotationDelta();\n  this.color = this.getColor();\n  this.shape = this.getShape();\n  this.image = this.getImage();\n  this.style = this.getStyle();\n  this.rotation = _.rotate ? radian(random(0, 360)) : 0;\n  this.vertical = _.direction > 150 && _.direction < 210 || _.direction > 330 && _.direction < 390 || _.direction > -30 && _.direction < 30;\n  this.horizontal = _.direction > 60 && _.direction < 120 || _.direction > 240 && _.direction < 300;\n};\n/**\n * initialise a particle with the default values from\n * the Sparticles instance settings.\n * these values do not change when the particle goes offscreen\n */\n\n\nSparticle.prototype.init = function () {\n  var _ = this.settings;\n  var canvas = this.canvas;\n  this.alpha = 0;\n\n  if (_.speed > 0 || _.alphaSpeed === 0) {\n    this.alpha = random(_.minAlpha, _.maxAlpha);\n  }\n\n  if (_.bounce) {\n    this.px = round(random(2, canvas.width - this.size - 2));\n    this.py = round(random(2, canvas.height - this.size - 2));\n  } else {\n    this.px = round(random(-this.size * 2, canvas.width + this.size));\n    this.py = round(random(-this.size * 2, canvas.height + this.size));\n  }\n};\n/**\n * reset the particle after it has gone off canvas.\n * this should be better than popping it from the array\n * and creating a new particle instance.\n */\n\n\nSparticle.prototype.reset = function () {\n  // give the particle a new set of initial values\n  this.setup(); // set the particle's Y position\n\n  if (this.py < 0) {\n    this.py = this.canvas.height + this.size * 2;\n  } else if (this.py > this.canvas.height) {\n    this.py = 0 - this.size * 2;\n  } // set the particle's X position\n\n\n  if (this.px < 0) {\n    this.px = this.canvas.width + this.size * 2;\n  } else if (this.px > this.canvas.width) {\n    this.px = 0 - this.size * 2;\n  }\n};\n/**\n * bounce the particle off the edge of canvas\n * when it has touched\n */\n\n\nSparticle.prototype.bounce = function () {\n  var _ = this.settings;\n  var dir = _.direction; // reverse the particle's Y position\n\n  if (this.py <= 0 || this.py + this.size >= this.canvas.height) {\n    this.dy = -this.dy;\n\n    if (this.horizontal) {\n      this.dd = -this.dd;\n    }\n  } // reverse the particle's X position\n\n\n  if (this.px <= 0 || this.px + this.size >= this.canvas.width) {\n    this.dx = -this.dx;\n\n    if (this.vertical) {\n      this.dd = -this.dd;\n    }\n  }\n};\n/**\n * check if the particle is off the canvas based\n * on it's current position\n * @returns {Boolean} is the particle completely off canvas\n */\n\n\nSparticle.prototype.isOffCanvas = function () {\n  var topleft = 0 - this.size * 2;\n  var bottom = this.canvas.height + this.size * 2;\n  var right = this.canvas.width + this.size * 2;\n  return this.px < topleft || this.px > right || this.py < topleft || this.py > bottom;\n};\n/**\n * check if the particle is touching the canvas edge\n * @returns {Boolean} is the particle touching edge\n */\n\n\nSparticle.prototype.isTouchingEdge = function () {\n  var topleft = 0;\n  var bottom = this.canvas.height - this.size;\n  var right = this.canvas.width - this.size;\n  return this.px < topleft || this.px > right || this.py < topleft || this.py > bottom;\n};\n/**\n * get a random color for the particle from the\n * array of colors set in the options object\n * @returns {String} - random color from color array\n */\n\n\nSparticle.prototype.getColor = function () {\n  if (this.settings.color === \"random\") {\n    return randomArray(this.colors);\n  } else if (Array.isArray(this.settings.color)) {\n    return randomArray(this.settings.color);\n  } else {\n    return this.settings.color;\n  }\n};\n/**\n * get a random shape for the particle from the\n * array of shapes set in the options object\n * @returns {String} - random shape from shape array\n */\n\n\nSparticle.prototype.getShape = function () {\n  if (this.settings.shape === \"random\") {\n    return randomArray(this.shapes);\n  } else if (Array.isArray(this.settings.shape)) {\n    return randomArray(this.settings.shape);\n  } else {\n    return this.settings.shape;\n  }\n};\n/**\n * get the image for the particle from the array\n * of possible image urls\n * @returns {String} - random imageUrl from imageUrl array\n */\n\n\nSparticle.prototype.getImage = function () {\n  if (Array.isArray(this.settings.imageUrl)) {\n    return randomArray(this.settings.imageUrl);\n  } else {\n    return this.settings.imageUrl;\n  }\n};\n/**\n * get the style of the particle, either \"fill\" or \"stroke\"\n * depending on the settings as fill/stroke/both\n * @returns {String} - either \"fill\" or \"stroke\"\n */\n\n\nSparticle.prototype.getStyle = function () {\n  return randomArray(this.styles);\n};\n/**\n * get a random delta (velocity) for the particle\n * based on the speed, and the parallax value (if applicable)\n * @returns {Number} - the velocity to be applied to the particle\n */\n\n\nSparticle.prototype.getDelta = function () {\n  var baseDelta = this.settings.speed * 0.1;\n\n  if (this.settings.speed && this.settings.parallax) {\n    return baseDelta + this.size * this.settings.parallax / 50;\n  } else {\n    return baseDelta;\n  }\n};\n/**\n * get a random variable speed for use as a multiplier,\n * based on the values given in the settings object, this\n * can be positive or negative\n * @returns {Number} - a variable delta speed\n */\n\n\nSparticle.prototype.getDeltaVariance = function () {\n  var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var s = this.settings.speed || 10;\n\n  if (v > 0) {\n    return random(-v, v) * s / 100;\n  } else {\n    return 0;\n  }\n};\n/**\n * get a random delta on the X axis, taking in to account\n * the variance range in the settings object and the particle's\n * direction as a multiplier\n * @returns {Number} - the X delta to be applied to particle\n */\n\n\nSparticle.prototype.getDeltaX = function () {\n  var d = this.getDelta();\n  var dv = this.getDeltaVariance(this.settings.xVariance);\n  return cartesian(this.settings.direction)[0] * d + dv;\n};\n/**\n * get a random delta on the Y axis, taking in to account\n * the variance range in the settings object and the particle's\n * direction as a multiplier\n * @returns {Number} - the Y delta to be applied to particle\n */\n\n\nSparticle.prototype.getDeltaY = function () {\n  var d = this.getDelta();\n  var dv = this.getDeltaVariance(this.settings.yVariance);\n  return cartesian(this.settings.direction)[1] * d + dv;\n};\n/**\n * get a random delta for the alpha change over time from\n * between a positive and negative alpha variance value\n * @returns {Number} - the alpha delta to be applied to particle\n */\n\n\nSparticle.prototype.getAlphaDelta = function () {\n  var variance = this.settings.alphaVariance;\n  var a = random(1, variance + 1);\n\n  if (roll(1 / 2)) {\n    a = -a;\n  }\n\n  return a;\n};\n/**\n * return a random drift value either positive or negative\n * @returns {Number} - the drift value\n */\n\n\nSparticle.prototype.getDriftDelta = function () {\n  if (!this.settings.drift) {\n    return 0;\n  } else {\n    return random(this.settings.drift - this.settings.drift / 2, this.settings.drift + this.settings.drift / 2);\n  }\n};\n/**\n * return a random rotation value either positive or negative\n * @returns {Number} - the rotation value\n */\n\n\nSparticle.prototype.getRotationDelta = function () {\n  var r = 0;\n\n  if (this.settings.rotate && this.settings.rotation) {\n    r = radian(random(0.5, 1.5) * this.settings.rotation);\n\n    if (roll(1 / 2)) {\n      r = -r;\n    }\n  }\n\n  return r;\n};\n/**\n * progress the particle's frame number, as well\n * as the internal values for both the particle's\n * position and the particle's alpha.\n * @returns {Object} - reference to the current Sparticle instance\n */\n\n\nSparticle.prototype.update = function () {\n  this.frame += 1;\n  this.updatePosition();\n  this.updateAlpha();\n  return this;\n};\n/**\n * progress the particle's alpha value depending on the\n * alphaSpeed and the twinkle setting\n * @returns {Number} - new alpha value of the particle\n */\n\n\nSparticle.prototype.updateAlpha = function () {\n  if (this.settings.alphaSpeed > 0) {\n    if (this.settings.twinkle) {\n      this.alpha = this.updateTwinkle();\n    } else {\n      this.alpha = this.updateFade();\n    }\n  }\n\n  return this.alpha;\n};\n/**\n * progress the particle's alpha value according to\n * the fading effect\n * @returns {Number} - new alpha value of the particle\n */\n\n\nSparticle.prototype.updateFade = function () {\n  var tick = this.da / 1000 * this.settings.alphaSpeed * 0.5;\n  var alpha = this.alpha + tick;\n  var over = this.da > 0 && alpha > this.settings.maxAlpha;\n  var under = this.da < 0 && alpha < this.settings.minAlpha; // if the alpha is over or under the min or max values,\n  // then we reverse the delta so that it can increase or\n  // decrease in opacity in the opposite direction\n\n  if (over || under) {\n    this.da = -this.da;\n    alpha = this.settings.maxAlpha;\n\n    if (under) {\n      alpha = this.settings.minAlpha;\n    }\n  }\n\n  return alpha;\n};\n/**\n * progress the particle's alpha value according to\n * the twinkle effect\n * @returns {Number} - new alpha value of the particle\n */\n\n\nSparticle.prototype.updateTwinkle = function () {\n  var alpha = this.alpha;\n  var delta = Math.abs(this.da);\n  var over = alpha > this.settings.maxAlpha;\n  var under = alpha < this.settings.minAlpha;\n  var tick = delta / 1000 * this.settings.alphaSpeed * 0.5;\n  var flickerOn = roll(1 / 30);\n  var flickerOff = roll(1 / 30); // if the particle is resetting the twinkle effect, then\n  // we simply want to quickly get back to max alpha\n  // over a short period of time, otherwise just advance the tick\n\n  if (this.resettingTwinkle) {\n    alpha += tick * 5;\n  } else if (flickerOn) {\n    alpha += tick * 50;\n  } else if (flickerOff) {\n    alpha -= tick * 25;\n  } else {\n    alpha -= tick;\n  } // once the alpha is under the min alpha value, then we need\n  // to set the twinkle effect to reset, and once it is over\n  // the max alpha, we stop resetting.\n\n\n  if (under) {\n    this.resettingTwinkle = true;\n    alpha = this.settings.minAlpha;\n  } else if (over) {\n    this.resettingTwinkle = false;\n    alpha = this.settings.maxAlpha;\n  }\n\n  return alpha;\n};\n/**\n * progress the particle's position values, rotation and drift\n * according to the settings given\n */\n\n\nSparticle.prototype.updatePosition = function () {\n  if (this.settings.bounce && this.isTouchingEdge()) {\n    this.bounce();\n  } else if (this.isOffCanvas()) {\n    this.reset();\n    return;\n  }\n\n  this.px += this.dx;\n  this.py += this.dy; // drift must be applied after position x/y\n  // as it modifies the values by wave function\n\n  this.updateDrift();\n  this.updateRotation();\n};\n/**\n * progress the particle's rotation value according\n * to the settings given\n */\n\n\nSparticle.prototype.updateRotation = function () {\n  if (this.settings.rotate && this.settings.rotation) {\n    this.rotation += this.dr;\n  }\n};\n/**\n * progress the particle's drift value according\n * to the settings given\n */\n\n\nSparticle.prototype.updateDrift = function () {\n  var _ = this.settings;\n  var dir = _.direction;\n\n  if (_.drift && _.speed) {\n    if (this.vertical) {\n      // apply HORIZONTAL drift ~ when \"direction\" is mostly vertical.\n      this.px += cartesian(this.frame + this.frameoffset)[0] * this.dd / (this.getDelta() * 15);\n    } else if (this.horizontal) {\n      // apply VERTICAL drift ~ when \"direction\" is mostly horizontal.\n      this.py += cartesian(this.frame + this.frameoffset)[1] * this.dd / (this.getDelta() * 15);\n    }\n  }\n};\n\nSparticle.prototype.render = function (canvasses) {\n  var particleCanvas;\n\n  if (this.shape !== \"image\") {\n    particleCanvas = canvasses[this.color][this.shape][this.style];\n  } else {\n    particleCanvas = canvasses[this.color][this.shape][this.image];\n  }\n\n  var canvasSize = particleCanvas.width;\n  var scale = this.size / canvasSize;\n  var px = this.px / scale;\n  var py = this.py / scale;\n  this.ctx.globalAlpha = clamp(this.alpha, 0, 1);\n  this.renderRotate();\n  this.ctx.transform(scale, 0, 0, scale, 0, 0);\n  this.ctx.drawImage(particleCanvas, 0, 0, canvasSize, canvasSize, px, py, canvasSize, canvasSize);\n  this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n  return this;\n};\n\nSparticle.prototype.renderRotate = function () {\n  if (this.shape !== \"circle\" && this.settings.rotate) {\n    var centerX = this.px + this.size / 2;\n    var centerY = this.py + this.size / 2;\n    this.ctx.translate(centerX, centerY);\n    this.ctx.rotate(this.rotation);\n    this.ctx.translate(-centerX, -centerY);\n  }\n};\n\n/**\n * Sparticles Constructor;\n * Create a <canvas>, append to the given node, and start the particle effect\n * @param {HTMLElement} [node=document.body] - element to which canvas is appended to\n * @param {Object} [options={}] - settings to use for the particle effect\n * @param {String} [options.composition=source-over] - canvas globalCompositeOperation value for particles\n * @param {Number} [options.count=50] - number of particles on the canvas simultaneously\n * @param {Number} [options.speed=10] - default velocity of every particle\n * @param {Number} [options.parallax=1] - speed multiplier effect for larger particles (0 = none)\n * @param {Number} [options.direction=180] - default direction of particles in degrees (0 = ↑, 180 = ↓)\n * @param {Number} [options.xVariance=2] - random deviation of particles on x-axis from default direction\n * @param {Number} [options.yVariance=2] - random deviation of particles on y-axis from default direction\n * @param {Number} [options.rotate=true] - can particles rotate\n * @param {Number} [options.rotation=1] - default rotational speed for every particle\n * @param {Number} [options.alphaSpeed=10] - rate of change in alpha over time\n * @param {Number} [options.alphaVariance=1] - random deviation of alpha change\n * @param {Number} [options.minAlpha=0] - minumum alpha value of every particle\n * @param {Number} [options.maxAlpha=1] - maximum alpha value of every particle\n * @param {Number} [options.minSize=1] - minimum size of every particle\n * @param {Number} [options.maxSize=10] - maximum size of every particle\n * @param {Boolean} [options.bounce=false] - should the particles bounce off edge of canvas\n * @param {Number} [options.drift=1] - the \"driftiness\" of particles which have a horizontal/vertical direction\n * @param {Number} [options.glow=0] - the glow effect size of each particle\n * @param {Boolean} [options.twinkle=false] - particles to exhibit an alternative alpha transition as \"twinkling\"\n * @param {String} [options.style=fill] - fill style of particles (one of; \"fill\", \"stroke\" or \"both\")\n * @param {(String|String[])} [options.shape=circle] - shape of particles (any of; circle, square, triangle, diamond, line, image) or \"random\"\n * @param {(String|String[])} [options.imageUrl=] - if shape is \"image\", define an image url (can be data-uri, must be square (1:1 ratio))\n * @param {(String|String[])} [options.color=random] - css color as string, or array of color strings (can also be \"random\")\n * @param {Function} [options.randomColor=randomHsl(index,total)] - a custom function for setting the random colors when color=\"random\"\n * @param {Number} [options.randomColorCount=3] - the number of random colors to generate when color is \"random\"\n * @param {Number} [width] - the width of the canvas element\n * @param {Number} [height=width] - the height of the canvas element\n * @returns {Object} - reference to a new Sparticles instance\n */\n\nvar Sparticles = function Sparticles(node, options, width, height) {\n  if (arguments.length >= 1 && !(arguments[0] instanceof HTMLElement)) {\n    options = arguments[0];\n    width = arguments[1];\n    height = arguments[2];\n    node = undefined;\n  }\n\n  if (width && !height) {\n    height = width;\n  }\n\n  var defaults = {\n    alphaSpeed: 10,\n    alphaVariance: 1,\n    bounce: false,\n    color: \"random\",\n    randomColor: randomHsl,\n    randomColorCount: 3,\n    composition: \"source-over\",\n    count: 50,\n    direction: 180,\n    drift: 1,\n    glow: 0,\n    imageUrl: \"\",\n    maxAlpha: 1,\n    maxSize: 10,\n    minAlpha: 0,\n    minSize: 1,\n    parallax: 1,\n    rotate: true,\n    rotation: 1,\n    shape: \"circle\",\n    speed: 10,\n    style: \"fill\",\n    twinkle: false,\n    xVariance: 2,\n    yVariance: 2\n  };\n  this.el = node || document.body;\n  this.settings = _objectSpread2(_objectSpread2({}, defaults), options);\n  this.resizable = !width && !height;\n  this.width = this.resizable ? this.el.clientWidth : width;\n  this.height = this.resizable ? this.el.clientHeight : height;\n  /**\n   * initialise the sparticles instance\n   * @returns {Object} - reference to the Sparticles instance\n   */\n\n  this.init = function () {\n    var _this = this;\n\n    this.sparticles = [];\n    this.colors = this.getColorArray();\n    this.shapes = this.getShapeArray();\n    this.styles = this.getStyleArray();\n    this.imageUrls = this.getImageArray();\n    this.setupMainCanvas();\n    this.setupOffscreenCanvasses(function () {\n      _this.createSparticles();\n\n      _this.start();\n    }); // defer to the default \"handleEvent\" handler\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventListener/handleEvent\n\n    window.addEventListener(\"resize\", this);\n    return this;\n  };\n  /**\n   * handle event for screen resize;\n   * debounce a canvas resize,\n   * reset the particles\n   */\n\n\n  this.handleEvent = function (event) {\n    var _this2 = this;\n\n    if (event.type === \"resize\") {\n      clearTimeout(this.resizeTimer);\n      this.resizeTimer = setTimeout(function () {\n        if (_this2.resizable) {\n          _this2.width = _this2.el.clientWidth;\n          _this2.height = _this2.el.clientHeight;\n\n          _this2.setCanvasSize().resetSparticles();\n        }\n      }, 200);\n    }\n  };\n  /**\n   * start/resume the sparticles animation\n   * @returns {Object} - the Sparticle instance (for chaining)\n   */\n\n\n  this.start = function () {\n    var me = this;\n\n    if (!this.loop) {\n      this.loop = new AnimationFrame(function (t) {\n        me.drawFrame(t);\n      });\n    }\n\n    this.loop.start();\n    return this;\n  };\n  /**\n   * stop/pause the sparticles animation\n   * @returns {Object} - the Sparticle instance (for chaining)\n   */\n\n\n  this.stop = function () {\n    this.loop.stop();\n    return this;\n  };\n  /**\n   * destroy the current instance and free up some memory\n   * @returns {Object} - the Sparticle instance (for chaining)\n   */\n\n\n  this.destroy = function () {\n    // stop the rendering and updating\n    this.stop(); // remove the canvas element from the DOM\n\n    this.el.removeChild(this.canvas); // remove the resize event for this instance\n\n    window.removeEventListener(\"resize\", this); // delete all the properties from the instance\n    // to free up memory\n\n    for (var prop in this) {\n      if (this.hasOwnProperty(prop)) {\n        delete this[prop];\n      }\n    }\n\n    return this;\n  };\n  /**\n   * set the canvas width and height\n   * @param {Number} width - the width of the canvas\n   * @param {Number} height - the height of the canvas\n   * @returns {Object} - the Sparticle instance (for chaining)\n   */\n\n\n  this.setCanvasSize = function (width, height) {\n    if (width) {\n      this.resizable = false;\n    }\n\n    this.width = width || this.width;\n    this.height = height || this.height;\n    this.canvas.width = this.width;\n    this.canvas.height = this.height;\n    return this;\n  };\n  /**\n   * create an array and populate it with new Sparticle instances.\n   * @returns {Array} the array of Sparticle instances\n   */\n\n\n  this.resetSparticles = this.createSparticles = function () {\n    this.sparticles = [];\n    this.ctx.globalCompositeOperation = this.settings.composition;\n\n    for (var i = 0; i < this.settings.count; i++) {\n      this.sparticles.push(new Sparticle(this, i));\n    }\n\n    this.sort();\n    return this.sparticles;\n  };\n  /**\n   * sort the particle array by size so that parallax effect\n   * doesn't appear to have slower/smaller particles in foreground\n   */\n\n\n  this.sort = function () {\n    if (this.settings.parallax) {\n      this.sparticles.sort(function (a, b) {\n        return a.size - b.size;\n      });\n    }\n  }; // initialise the sparticles, and return the instance.\n\n\n  return this.init();\n};\n/**\n * convert the input color to an array if it isn't already\n * @returns {Array} - array of colors for use in rendering\n */\n\n\nSparticles.prototype.getColorArray = function () {\n  var colors = Array.isArray(this.settings.color) ? this.settings.color : [this.settings.color];\n  var isRandom = colors.some(function (c) {\n    return c === \"random\";\n  });\n\n  if (isRandom) {\n    for (var i = 0; i < this.settings.randomColorCount; i++) {\n      colors[i] = this.settings.randomColor(i, this.settings.randomColorCount);\n    }\n  }\n\n  return colors;\n};\n/**\n * convert the input shape to an array if it isn't already\n * @returns {Array} - array of shapes for use in rendering\n */\n\n\nSparticles.prototype.getShapeArray = function () {\n  var shapes = Array.isArray(this.settings.shape) ? this.settings.shape : [this.settings.shape];\n  var isRandom = shapes.some(function (c) {\n    return c === \"random\";\n  });\n\n  if (isRandom) {\n    shapes = [\"square\", \"circle\", \"triangle\"];\n  }\n\n  return shapes;\n};\n/**\n * convert the imageUrl option to an array if it isn't already\n * @returns {Array} - array of image urls for use in rendering\n */\n\n\nSparticles.prototype.getImageArray = function () {\n  return Array.isArray(this.settings.imageUrl) ? this.settings.imageUrl : [this.settings.imageUrl];\n};\n/**\n * convert the input style to an array\n * @returns {Array} - array of styles for use in rendering\n */\n\n\nSparticles.prototype.getStyleArray = function () {\n  var styles = this.settings.style;\n\n  if (styles !== \"fill\" && styles !== \"stroke\") {\n    styles = [\"fill\", \"stroke\"];\n  } else {\n    styles = [styles];\n  }\n\n  return styles;\n};\n/**\n * set up the canvas and bind to a property for\n * access later on, append it to the DOM\n * @returns {HTMLCanvasElement} - the canvas element which was appended to DOM\n */\n\n\nSparticles.prototype.setupMainCanvas = function () {\n  this.canvas = document.createElement(\"canvas\");\n  this.canvas.setAttribute(\"class\", \"sparticles\");\n  this.ctx = this.canvas.getContext(\"2d\");\n  this.setCanvasSize();\n  this.el.appendChild(this.canvas);\n  return this.canvas;\n};\n/**\n * create a new offscreen canvas element for each color & shape\n * combination, so that we can reference it later during render\n * (huge performance gains here)\n * @param {Function} [callback] - function to execute after image loads\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.setupOffscreenCanvasses = function (callback) {\n  var _this3 = this;\n\n  var colors = this.colors.filter(function (item, index) {\n    return _this3.colors.indexOf(item) === index;\n  });\n  var shapes = this.shapes.filter(function (item, index) {\n    return _this3.shapes.indexOf(item) === index;\n  });\n  var styles = this.styles.filter(function (item, index) {\n    return _this3.styles.indexOf(item) === index;\n  });\n  var imageUrls = this.imageUrls.filter(function (item, index) {\n    return _this3.imageUrls.indexOf(item) === index;\n  });\n  var imageCount = colors.length * imageUrls.length;\n  var canvasCount = colors.length * shapes.length * styles.length;\n  var imagesLoaded = 0;\n  var canvassesCreated = 0;\n  this.canvasses = this.canvasses || {};\n  colors.forEach(function (color) {\n    _this3.canvasses[color] = _this3.canvasses[color] || {};\n    shapes.forEach(function (shape) {\n      _this3.canvasses[color][shape] = _this3.canvasses[color][shape] || {};\n\n      if (shape === \"image\") {\n        imageUrls.forEach(function (imageUrl, i) {\n          var image = new Image();\n          var imageCanvas = document.createElement(\"canvas\");\n          _this3.canvasses[color][shape][imageUrl] = imageCanvas;\n\n          image.onload = function () {\n            imagesLoaded++;\n\n            _this3.drawOffscreenCanvasForImage(image, color, imageCanvas);\n\n            if (callback && imagesLoaded === imageCount) {\n              callback();\n            }\n          };\n\n          image.onerror = function () {\n            console.error(\"failed to load source image: \", imageUrl);\n          };\n\n          image.src = imageUrl;\n        });\n      } else {\n        styles.forEach(function (style) {\n          var canvas = document.createElement(\"canvas\");\n          _this3.canvasses[color][shape][style] = canvas;\n          canvassesCreated++;\n\n          _this3.drawOffscreenCanvas(shape, style, color, canvas);\n\n          if (callback && canvassesCreated === canvasCount) {\n            callback();\n          }\n        });\n      }\n    });\n  });\n};\n/**\n * return the size of the glow effect (shadowBlur) for each particle\n * @param {Number} size - the size of the particle\n * @returns {Number} - the size of the glow/shadow\n */\n\n\nSparticles.prototype.getGlowSize = function (size) {\n  return this.settings.glow;\n};\n/**\n * return the outline or stroke size of each particle\n * @param {Number} size - the size of the particle\n * @returns {Number} - the size of the outline/stroke\n */\n\n\nSparticles.prototype.getLineSize = function (size) {\n  return clamp(size / 20, 1, 5);\n};\n/**\n * return the offscreenCanvas size to generate for\n * @returns {Number} - the maxSize of the offscreen canvas\n */\n\n\nSparticles.prototype.getOffscreenCanvasSize = function () {\n  return clamp(this.settings.maxSize, this.settings.minSize, this.settings.maxSize);\n};\n/**\n * set the fill/stroke style (color & width) for each particle's offscreen canvas\n * @param {CanvasRenderingContext2D} ctx - the canvas context\n * @param {String} color - the color to fill/stroke with\n * @param {Number} lineSize - size/thickness of the stroke\n * @param {String} style - style (either \"fill\" or \"stroke\")\n */\n\n\nSparticles.prototype.renderStyle = function (ctx, color, lineSize, style) {\n  if (style === \"fill\") {\n    ctx.fillStyle = color;\n  } else {\n    ctx.lineWidth = lineSize;\n    ctx.strokeStyle = color;\n  }\n};\n/**\n * set the shadowBlur (glow effect) for each particle's offscreen canvas\n * @param {CanvasRenderingContext2D} ctx - the canvas context\n * @param {String} color - the color to fill/stroke with\n * @param {Number} size - size of the shadow/glow\n */\n\n\nSparticles.prototype.renderGlow = function (ctx, color, size) {\n  var glowSize = this.getGlowSize(size) / 2;\n  ctx.shadowColor = color;\n  ctx.shadowBlur = glowSize;\n};\n/**\n * fill or stroke each particle's offscreen canvas depending on the given setting\n * @param {CanvasRenderingContext2D} ctx - the canvas context\n * @param {String} style - style (either \"fill\" or \"stroke\")\n */\n\n\nSparticles.prototype.renderColor = function (ctx, style, path) {\n  if (style === \"fill\") {\n    if (path) {\n      ctx.fill(path);\n    } else {\n      ctx.fill();\n    }\n  } else {\n    if (path) {\n      ctx.stroke(path);\n    } else {\n      ctx.stroke();\n    }\n  }\n};\n/**\n * pass-through the needed parameters to the offscreen canvas\n * draw function associated with the given shape\n * @param {String} shape -  shape of the canvas to draw (eg: \"circle\")\n * @param {String} style -  style (either \"fill\" or \"stroke\")\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.drawOffscreenCanvas = function (shape, style, color, canvas) {\n  return this.offScreenCanvas[shape].call(this, style, color, canvas);\n};\n/**\n * object of shapes to draw\n */\n\n\nSparticles.prototype.offScreenCanvas = {};\n/**\n * create, setup and render an offscreen canvas for a\n * Circle Particle of the given color\n * @param {String} style -  style (either \"fill\" or \"stroke\")\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\nSparticles.prototype.offScreenCanvas.circle = function (style, color, canvas) {\n  var ctx = canvas.getContext(\"2d\");\n  var size = this.getOffscreenCanvasSize();\n  var lineSize = this.getLineSize(size);\n  var glowSize = this.getGlowSize(size);\n  var canvasSize = size + lineSize * 2 + glowSize;\n  var shapeSize = style === \"stroke\" ? size - lineSize : size;\n  canvas.width = canvasSize;\n  canvas.height = canvasSize;\n  this.renderGlow(ctx, color, size);\n  this.renderStyle(ctx, color, lineSize, style);\n  ctx.beginPath();\n  ctx.ellipse(canvasSize / 2, canvasSize / 2, shapeSize / 2, shapeSize / 2, 0, 0, 360);\n  this.renderColor(ctx, style);\n  return canvas;\n};\n/**\n * create, setup and render an offscreen canvas for a\n * Square Particle of the given color\n * @param {String} style -  style (either \"fill\" or \"stroke\")\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.offScreenCanvas.square = function (style, color, canvas) {\n  var ctx = canvas.getContext(\"2d\");\n  var size = this.getOffscreenCanvasSize();\n  var lineSize = this.getLineSize(size);\n  var glowSize = this.getGlowSize(size);\n  var canvasSize = size + lineSize * 2 + glowSize;\n  var shapeSize = style === \"stroke\" ? size - lineSize : size;\n  canvas.width = canvasSize;\n  canvas.height = canvasSize;\n  this.renderGlow(ctx, color, size);\n  this.renderStyle(ctx, color, lineSize, style);\n  ctx.beginPath();\n  ctx.rect(canvasSize / 2 - shapeSize / 2, canvasSize / 2 - shapeSize / 2, shapeSize, shapeSize);\n  this.renderColor(ctx, style);\n  return canvas;\n};\n/**\n * create, setup and render an offscreen canvas for a\n * Line/Curve Particle of the given color\n * @param {String} style -  style (either \"fill\" or \"stroke\")\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.offScreenCanvas.line = function (style, color, canvas) {\n  var ctx = canvas.getContext(\"2d\");\n  var size = this.getOffscreenCanvasSize() * 1.5;\n  var lineSize = this.getLineSize(size);\n  var glowSize = this.getGlowSize(size);\n  var canvasSize = size + lineSize * 2 + glowSize;\n  var startx = canvasSize / 2 - size / 2;\n  var starty = canvasSize / 2 - size / 2;\n  canvas.width = canvasSize;\n  canvas.height = canvasSize;\n  this.renderGlow(ctx, color, size);\n  ctx.lineWidth = lineSize;\n  ctx.strokeStyle = color;\n  ctx.beginPath();\n  ctx.moveTo(startx, starty);\n  ctx.lineTo(startx + size, starty + size);\n  ctx.stroke();\n  ctx.closePath();\n  return canvas;\n};\n/**\n * create, setup and render an offscreen canvas for a\n * Triangle Particle of the given color\n * @param {String} style -  style (either \"fill\" or \"stroke\")\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.offScreenCanvas.triangle = function (style, color, canvas) {\n  var ctx = canvas.getContext(\"2d\");\n  var size = this.getOffscreenCanvasSize();\n  var lineSize = this.getLineSize(size);\n  var glowSize = this.getGlowSize(size);\n  var canvasSize = size + lineSize * 2 + glowSize;\n  var shapeSize = style === \"stroke\" ? size - lineSize : size;\n  var height = shapeSize * (Math.sqrt(3) / 2);\n  var startx = canvasSize / 2;\n  var starty = canvasSize / 2 - shapeSize / 2;\n  canvas.width = canvasSize;\n  canvas.height = canvasSize;\n  this.renderGlow(ctx, color, size);\n  this.renderStyle(ctx, color, lineSize, style);\n  ctx.beginPath();\n  ctx.moveTo(startx, starty);\n  ctx.lineTo(startx - shapeSize / 2, starty + height);\n  ctx.lineTo(startx + shapeSize / 2, starty + height);\n  ctx.closePath();\n  this.renderColor(ctx, style);\n  return canvas;\n};\n/**\n * create, setup and render an offscreen canvas for a\n * Diamond Sparkle Particle of the given color\n * @param {String} style -  style (either \"fill\" or \"stroke\")\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.offScreenCanvas.diamond = function (style, color, canvas) {\n  var pathSize = 100;\n  var path = new Path2D(\"M43,83.74,48.63,99a1.46,1.46,0,0,0,2.74,0L57,83.74A45.09,45.09,0,0,1,83.74,57L99,51.37a1.46,1.46,0,0,0,0-2.74L83.74,43A45.11,45.11,0,0,1,57,16.26L51.37,1a1.46,1.46,0,0,0-2.74,0L43,16.26A45.11,45.11,0,0,1,16.26,43L1,48.63a1.46,1.46,0,0,0,0,2.74L16.26,57A45.09,45.09,0,0,1,43,83.74Z\");\n  var ctx = canvas.getContext(\"2d\");\n  var size = this.getOffscreenCanvasSize();\n  var lineSize = this.getLineSize(size);\n  var glowSize = this.getGlowSize(size);\n  var canvasSize = size + lineSize * 2 + glowSize;\n  var scale = canvasSize / ((pathSize + glowSize) * 1.1);\n  canvas.width = canvasSize;\n  canvas.height = canvasSize;\n  this.renderGlow(ctx, color, size);\n  this.renderStyle(ctx, color, lineSize / scale, style);\n  ctx.scale(scale, scale);\n  ctx.translate(pathSize * 0.05 + glowSize * 0.5, pathSize * 0.05 + glowSize * 0.5);\n  this.renderColor(ctx, style, path);\n  return canvas;\n};\n/**\n * create, setup and render an offscreen canvas for a\n * Star Particle of the given color\n * @param {String} style -  style (either \"fill\" or \"stroke\")\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.offScreenCanvas.star = function (style, color, canvas) {\n  var pathSize = 100;\n  var path = new Path2D(\"M99.86,36.45a2.94,2.94,0,0,0-2.37-2l-31-4.54L52.63,1.64a2.93,2.93,0,0,0-5.26,0L33.51,29.91l-31,4.54a3,3,0,0,0-2.37,2,3,3,0,0,0,.74,3l22.44,22L18,92.55A2.94,2.94,0,0,0,20.91,96a2.86,2.86,0,0,0,1.36-.34L50,81,77.73,95.66a2.91,2.91,0,0,0,3.08-.22A3,3,0,0,0,82,92.55l-5.3-31.07,22.44-22A3,3,0,0,0,99.86,36.45Z\");\n  var ctx = canvas.getContext(\"2d\");\n  var size = this.getOffscreenCanvasSize();\n  var lineSize = this.getLineSize(size);\n  var glowSize = this.getGlowSize(size);\n  var canvasSize = size + lineSize * 2 + glowSize;\n  var scale = canvasSize / ((pathSize + glowSize) * 1.1);\n  canvas.width = canvasSize;\n  canvas.height = canvasSize;\n  ctx.scale(scale, scale);\n  this.renderGlow(ctx, color, size);\n  this.renderStyle(ctx, color, lineSize / scale, style);\n  ctx.translate(pathSize * 0.05 + glowSize * 0.5, pathSize * 0.05 + glowSize * 0.5);\n  this.renderColor(ctx, style, path);\n  return canvas;\n};\n/**\n * create, setup and render an offscreen canvas for a\n * Custom Image Particle of the given color\n * @param {HTMLImageElement} image - the image element that has loaded\n * @param {String} color - the color to fill/stroke with\n * @param {HTMLCanvasElement} canvas - the canvas element\n * @returns {HTMLCanvasElement} - the created offscreen canvas\n */\n\n\nSparticles.prototype.drawOffscreenCanvasForImage = function (image, color, canvas) {\n  var size = image.width;\n  var ctx = canvas.getContext(\"2d\");\n  canvas.width = size;\n  canvas.height = size;\n  ctx.drawImage(image, 0, 0, size, size, 0, 0, size, size);\n  ctx.globalCompositeOperation = \"source-atop\";\n  ctx.fillStyle = color;\n  ctx.fillRect(0, 0, size, size);\n  return canvas;\n};\n/**\n * - wipe the canvas,\n * - update each sparticle,\n * - render each sparticle\n * - sort so that larger particles on top\n * @returns {Array} the array of Sparticle instances\n */\n\n\nSparticles.prototype.drawFrame = function () {\n  this.ctx.clearRect(0, 0, this.width, this.height);\n\n  for (var i = 0; i < this.sparticles.length; i++) {\n    var sparticle = this.sparticles[i];\n    sparticle.update().render(this.canvasses);\n  }\n\n  this.sort();\n  return this.sparticles;\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sparticles);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vc3BhcnRpY2xlc0AxLjMuMS9ub2RlX21vZHVsZXMvc3BhcnRpY2xlcy9kaXN0L3NwYXJ0aWNsZXMubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FB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QSxhQUFhLE9BQU87QUFDcEI7OztBQUdBO0FBQ0E7O0FBRUEsa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFVBQVUsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy8ucG5wbS9zcGFydGljbGVzQDEuMy4xL25vZGVfbW9kdWxlcy9zcGFydGljbGVzL2Rpc3Qvc3BhcnRpY2xlcy5tanM/NmUzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiohXG4gKiBTcGFydGljbGVzIC0gTGlnaHR3ZWlnaHQsIEhpZ2ggUGVyZm9ybWFuY2UgUGFydGljbGVzIGluIENhbnZhc1xuICogQHZlcnNpb24gMS4zLjFcbiAqIEBsaWNlbnNlIE1QTC0yLjBcbiAqIEBhdXRob3Igc2ltZXlkb3RtZSA8c2ltZXkubWVAZ21haWwuY29tPlxuICogQHdlYnNpdGUgaHR0cDovL3NwYXJ0aWNsZXNqcy5kZXZcbiAqIEByZXBvc2l0b3J5IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW1leWRvdG1lL3NwYXJ0aWNsZXMuZ2l0XG4gKi9cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuXG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGltaXRlZCBBbmltYXRpb24gRnJhbWUgbWV0aG9kLCB0byBhbGxvdyBydW5uaW5nXG4gKiBhIGdpdmVuIGhhbmRsZXIgYXQgdGhlIG1heGltdW0gZGVzaXJlZCBmcmFtZSByYXRlLlxuICogaW5zcGlyZWQgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9hZGR5b3NtYW5pLzU0MzQ1MzNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgbWV0aG9kIHRvIGV4ZWN1dGUgdXBvbiBldmVyeSBmcmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IGZwcyBob3cgbWFueSBmcmFtZXMgdG8gcmVuZGVyIGV2ZXJ5IHNlY29uZFxuICovXG52YXIgQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiBBbmltYXRpb25GcmFtZSgpIHtcbiAgdmFyIGhhbmRsZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZ1bmN0aW9uICgpIHt9O1xuICB2YXIgZnBzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA2MDtcbiAgdGhpcy5mcHMgPSBmcHM7XG4gIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gIHZhciByZW5kZXJJZCA9IDA7XG4gIC8qKlxuICAgKiBiZWdpbiB0aGUgYW5pbWF0aW9uIGxvb3Agd2hpY2ggaXMgYXNzaWduZWRcbiAgICogdG8gdGhlIGluc3RhbmNlIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgKi9cblxuICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgdmFyIHRoZW4gPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHZhciBpbnRlcnZhbCA9IDEwMDAgLyB0aGlzLmZwcztcbiAgICAgIHZhciB0b2xlcmFuY2UgPSAwO1xuXG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uIGxvb3Aobm93KSB7XG4gICAgICAgIHZhciBkZWx0YSA9IG5vdyAtIHRoZW47XG4gICAgICAgIHJlbmRlcklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuXG4gICAgICAgIGlmIChkZWx0YSA+PSBpbnRlcnZhbCAtIHRvbGVyYW5jZSkge1xuICAgICAgICAgIF90aGlzLmhhbmRsZXIoZGVsdGEpO1xuXG4gICAgICAgICAgdGhlbiA9IG5vdyAtIGRlbHRhICUgaW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlbmRlcklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBzdG9wIHRoZSBjdXJyZW50bHkgcnVubmluZyBhbmltYXRpb24gbG9vcFxuICAgKi9cblxuXG4gIHRoaXMuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZW5kZXJJZCk7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gIH07XG59O1xuXG4vKipcbiAqIHJldHVybiB0aGUgY2FydGVzaWFuIHgveSBkZWx0YSB2YWx1ZSBmcm9tIGEgZGVncmVlXG4gKiBlZzogOTAgKOKGkikgPSBbMSwwXVxuICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIGFuZ2xlIGluIGRlZ3JlZXNcbiAqIEByZXR1cm5zIHtOdW1iZXJbXX0gY2FydGVzaWFuIGRlbHRhIHZhbHVlc1xuICovXG52YXIgY2FydGVzaWFuID0gZnVuY3Rpb24gY2FydGVzaWFuKGFuZ2xlKSB7XG4gIHJldHVybiBbTWF0aC5jb3MocmFkaWFuKGFuZ2xlIC0gOTApKSwgTWF0aC5zaW4ocmFkaWFuKGFuZ2xlIC0gOTApKV07XG59O1xuLyoqXG4gKiBjbGFtcCB0aGUgaW5wdXQgbnVtYmVyIHRvIHRoZSBtaW4vbWF4IHZhbHVlc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHZhbHVlIHRvIGNsYW1wIGJldHdlZW4gbWluIGFuZCBtYXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gbWluaW11bSB2YWx1ZSBwb3NzaWJsZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCBtYXhpbXVtIHZhbHVlIHBvc3NpYmxlXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgaW5wdXQgbnVtIGNsYW1wZWQgYmV0d2VlbiBtaW4vbWF4XG4gKi9cblxudmFyIGNsYW1wID0gZnVuY3Rpb24gY2xhbXAodmFsdWUpIHtcbiAgdmFyIG1pbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIG1heCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufTtcbi8qKlxuICogcmV0dXJuIHRoZSByYWRpYW4gZXF1aXZhbGVudCB0byBhIGRlZ3JlZSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIGFuZ2xlIGluIGRlZ3JlZXNcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHJhZGlhbiBlcXVpdmFsZW50XG4gKi9cblxudmFyIHJhZGlhbiA9IGZ1bmN0aW9uIHJhZGlhbihhbmdsZSkge1xuICByZXR1cm4gYW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xufTtcbi8qKlxuICogcmV0dXJuIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBhIG1pbiBhbmQgbWF4IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gbWluIG1pbmltdW0gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggbWF4aW11bSB2YWx1ZVxuICogQHBhcmFtIHtCb29sZWFufSByb3VuZGVkIHNob3VsZCB0aGUgcmVzdWx0IGJlIHJvdW5kZWRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBhbmQgbWF4XG4gKi9cblxudmFyIHJhbmRvbSA9IGZ1bmN0aW9uIHJhbmRvbSgpIHtcbiAgdmFyIG1pbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgdmFyIG1heCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgdmFyIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBNYXRoLnJhbmRvbSgpO1xuXG4gIGlmIChtYXggPD0gbWluKSB7XG4gICAgdmFsdWUgPSBtaW47XG4gIH0gZWxzZSBpZiAoKG1pbiAhPT0gMCB8fCBtYXggIT09IDEpICYmIG1heCA+IG1pbikge1xuICAgIHZhbHVlID0gdmFsdWUgKiAobWF4IC0gbWluKSArIG1pbjtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIHJldHVybiBhIHJhbmRvbSB2YWx1ZSBmcm9tIGFuIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBhbiBhcnJheSB0byBnZXQgcmFuZG9tIHZhbHVlIGZyb21cbiAqIEByZXR1cm5zIHsqfSByYW5kb20gdmFsdWUgZnJvbSBhcnJheVxuICovXG5cbnZhciByYW5kb21BcnJheSA9IGZ1bmN0aW9uIHJhbmRvbUFycmF5KGFycmF5KSB7XG4gIHJldHVybiBhcnJheVtNYXRoLmZsb29yKHJhbmRvbSgwLCBhcnJheS5sZW5ndGgpKV07XG59O1xuLyoqXG4gKiByZXR1cm4gYSByYW5kb20gSFNMIGNvbG91ciBzdHJpbmcgZm9yIHVzZSBpbiByYW5kb20gY29sb3IgZWZmZWN0XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBcImhzbCgxMDAsMTAwLDgwKVwiXG4gKi9cblxudmFyIHJhbmRvbUhzbCA9IGZ1bmN0aW9uIHJhbmRvbUhzbCgpIHtcbiAgdmFyIGggPSByb3VuZChyYW5kb20oMCwgMzYwKSk7XG4gIHZhciBzID0gcm91bmQocmFuZG9tKDkwLCAxMDApKTtcbiAgdmFyIGwgPSByb3VuZChyYW5kb20oNDUsIDg1KSk7XG4gIHJldHVybiBcImhzbChcIi5jb25jYXQoaCwgXCIsXCIpLmNvbmNhdChzLCBcIiUsXCIpLmNvbmNhdChsLCBcIiUpXCIpO1xufTtcbi8qKlxuICogcmV0dXJuIGEgYm9vbGVhbiB0byBwYXNzIGEgZGljZSByb2xsXG4gKiBAcGFyYW0ge051bWJlcn0gb2RkcyBhIGZyYWN0aW9uIHRvIHVzZSBhcyB0aGUgcHJvYmFiaWxpdHksIGNhbiBiZSBzdXBwbGllZCBhcyBcIjEvMlwiXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuXG52YXIgcm9sbCA9IGZ1bmN0aW9uIHJvbGwob2Rkcykge1xuICByZXR1cm4gb2RkcyA+IHJhbmRvbSgpO1xufTtcbi8qKlxuICogcm91bmQgYSBudW1iZXIgdG8gdGhlIG5lYXJlc3QgaW50ZWdlciB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHZhbHVlIHRvIHJvdW5kIHRvIHRoZSBuZWFyZXN0IGludGVnZXJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IG5lYXJlc3QgaW50ZWdlclxuICovXG5cbnZhciByb3VuZCA9IGZ1bmN0aW9uIHJvdW5kKHZhbHVlKSB7XG4gIHJldHVybiAwLjUgKyB2YWx1ZSB8IDA7XG59O1xuXG4vKipcbiAqIFNwYXJ0aWNsZSBDb25zdHJ1Y3RvcjtcbiAqIGNyZWF0ZXMgYW4gaW5kaXZpZHVhbCBwYXJ0aWNsZSBmb3IgdXNlIGluIHRoZSBTcGFydGljbGVzKCkgY2xhc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgLSB0aGUgcGFyZW50IFNwYXJ0aWNsZXMoKSBpbnN0YW5jZSB0aGlzIGJlbG9uZ3MgdG9cbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gcmVmZXJlbmNlIHRvIGEgbmV3IFNwYXJ0aWNsZSBpbnN0YW5jZVxuICovXG5cbnZhciBTcGFydGljbGUgPSBmdW5jdGlvbiBTcGFydGljbGUocGFyZW50KSB7XG4gIGlmIChwYXJlbnQpIHtcbiAgICB0aGlzLmNhbnZhcyA9IHBhcmVudC5jYW52YXM7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHBhcmVudC5zZXR0aW5ncztcbiAgICB0aGlzLmNvbG9ycyA9IHBhcmVudC5jb2xvcnM7XG4gICAgdGhpcy5zaGFwZXMgPSBwYXJlbnQuc2hhcGVzO1xuICAgIHRoaXMuaW1hZ2VzID0gcGFyZW50LmltYWdlcztcbiAgICB0aGlzLnN0eWxlcyA9IHBhcmVudC5zdHlsZXM7XG4gICAgdGhpcy5jdHggPSBwYXJlbnQuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICB0aGlzLnNldHVwKCk7XG4gICAgdGhpcy5pbml0KCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBwYXJhbWV0ZXJzIGdpdmVuIHRvIFNwYXJ0aWNsZSgpXCIsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIHNldCB1cCB0aGUgcGFydGljbGUgd2l0aCBzb21lIHJhbmRvbSB2YWx1ZXNcbiAqIGJlZm9yZSBpdCBpcyBpbml0aWFsaXNlZCBvbiB0aGUgY2FudmFzXG4gKiB0aGVzZSB2YWx1ZXMgd2lsbCByYW5kb21pemUgd2hlbiB0aGUgcGFydGljbGUgZ29lcyBvZmZzY3JlZW5cbiAqL1xuXG5TcGFydGljbGUucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgXyA9IHRoaXMuc2V0dGluZ3M7XG4gIHRoaXMuZnJhbWUgPSAwO1xuICB0aGlzLmZyYW1lb2Zmc2V0ID0gcm91bmQocmFuZG9tKDAsIDM2MCkpO1xuICB0aGlzLnNpemUgPSByb3VuZChyYW5kb20oXy5taW5TaXplLCBfLm1heFNpemUpKTtcbiAgdGhpcy5kYSA9IHRoaXMuZ2V0QWxwaGFEZWx0YSgpO1xuICB0aGlzLmR4ID0gdGhpcy5nZXREZWx0YVgoKTtcbiAgdGhpcy5keSA9IHRoaXMuZ2V0RGVsdGFZKCk7XG4gIHRoaXMuZGQgPSB0aGlzLmdldERyaWZ0RGVsdGEoKTtcbiAgdGhpcy5kciA9IHRoaXMuZ2V0Um90YXRpb25EZWx0YSgpO1xuICB0aGlzLmNvbG9yID0gdGhpcy5nZXRDb2xvcigpO1xuICB0aGlzLnNoYXBlID0gdGhpcy5nZXRTaGFwZSgpO1xuICB0aGlzLmltYWdlID0gdGhpcy5nZXRJbWFnZSgpO1xuICB0aGlzLnN0eWxlID0gdGhpcy5nZXRTdHlsZSgpO1xuICB0aGlzLnJvdGF0aW9uID0gXy5yb3RhdGUgPyByYWRpYW4ocmFuZG9tKDAsIDM2MCkpIDogMDtcbiAgdGhpcy52ZXJ0aWNhbCA9IF8uZGlyZWN0aW9uID4gMTUwICYmIF8uZGlyZWN0aW9uIDwgMjEwIHx8IF8uZGlyZWN0aW9uID4gMzMwICYmIF8uZGlyZWN0aW9uIDwgMzkwIHx8IF8uZGlyZWN0aW9uID4gLTMwICYmIF8uZGlyZWN0aW9uIDwgMzA7XG4gIHRoaXMuaG9yaXpvbnRhbCA9IF8uZGlyZWN0aW9uID4gNjAgJiYgXy5kaXJlY3Rpb24gPCAxMjAgfHwgXy5kaXJlY3Rpb24gPiAyNDAgJiYgXy5kaXJlY3Rpb24gPCAzMDA7XG59O1xuLyoqXG4gKiBpbml0aWFsaXNlIGEgcGFydGljbGUgd2l0aCB0aGUgZGVmYXVsdCB2YWx1ZXMgZnJvbVxuICogdGhlIFNwYXJ0aWNsZXMgaW5zdGFuY2Ugc2V0dGluZ3MuXG4gKiB0aGVzZSB2YWx1ZXMgZG8gbm90IGNoYW5nZSB3aGVuIHRoZSBwYXJ0aWNsZSBnb2VzIG9mZnNjcmVlblxuICovXG5cblxuU3BhcnRpY2xlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgXyA9IHRoaXMuc2V0dGluZ3M7XG4gIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgdGhpcy5hbHBoYSA9IDA7XG5cbiAgaWYgKF8uc3BlZWQgPiAwIHx8IF8uYWxwaGFTcGVlZCA9PT0gMCkge1xuICAgIHRoaXMuYWxwaGEgPSByYW5kb20oXy5taW5BbHBoYSwgXy5tYXhBbHBoYSk7XG4gIH1cblxuICBpZiAoXy5ib3VuY2UpIHtcbiAgICB0aGlzLnB4ID0gcm91bmQocmFuZG9tKDIsIGNhbnZhcy53aWR0aCAtIHRoaXMuc2l6ZSAtIDIpKTtcbiAgICB0aGlzLnB5ID0gcm91bmQocmFuZG9tKDIsIGNhbnZhcy5oZWlnaHQgLSB0aGlzLnNpemUgLSAyKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5weCA9IHJvdW5kKHJhbmRvbSgtdGhpcy5zaXplICogMiwgY2FudmFzLndpZHRoICsgdGhpcy5zaXplKSk7XG4gICAgdGhpcy5weSA9IHJvdW5kKHJhbmRvbSgtdGhpcy5zaXplICogMiwgY2FudmFzLmhlaWdodCArIHRoaXMuc2l6ZSkpO1xuICB9XG59O1xuLyoqXG4gKiByZXNldCB0aGUgcGFydGljbGUgYWZ0ZXIgaXQgaGFzIGdvbmUgb2ZmIGNhbnZhcy5cbiAqIHRoaXMgc2hvdWxkIGJlIGJldHRlciB0aGFuIHBvcHBpbmcgaXQgZnJvbSB0aGUgYXJyYXlcbiAqIGFuZCBjcmVhdGluZyBhIG5ldyBwYXJ0aWNsZSBpbnN0YW5jZS5cbiAqL1xuXG5cblNwYXJ0aWNsZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGdpdmUgdGhlIHBhcnRpY2xlIGEgbmV3IHNldCBvZiBpbml0aWFsIHZhbHVlc1xuICB0aGlzLnNldHVwKCk7IC8vIHNldCB0aGUgcGFydGljbGUncyBZIHBvc2l0aW9uXG5cbiAgaWYgKHRoaXMucHkgPCAwKSB7XG4gICAgdGhpcy5weSA9IHRoaXMuY2FudmFzLmhlaWdodCArIHRoaXMuc2l6ZSAqIDI7XG4gIH0gZWxzZSBpZiAodGhpcy5weSA+IHRoaXMuY2FudmFzLmhlaWdodCkge1xuICAgIHRoaXMucHkgPSAwIC0gdGhpcy5zaXplICogMjtcbiAgfSAvLyBzZXQgdGhlIHBhcnRpY2xlJ3MgWCBwb3NpdGlvblxuXG5cbiAgaWYgKHRoaXMucHggPCAwKSB7XG4gICAgdGhpcy5weCA9IHRoaXMuY2FudmFzLndpZHRoICsgdGhpcy5zaXplICogMjtcbiAgfSBlbHNlIGlmICh0aGlzLnB4ID4gdGhpcy5jYW52YXMud2lkdGgpIHtcbiAgICB0aGlzLnB4ID0gMCAtIHRoaXMuc2l6ZSAqIDI7XG4gIH1cbn07XG4vKipcbiAqIGJvdW5jZSB0aGUgcGFydGljbGUgb2ZmIHRoZSBlZGdlIG9mIGNhbnZhc1xuICogd2hlbiBpdCBoYXMgdG91Y2hlZFxuICovXG5cblxuU3BhcnRpY2xlLnByb3RvdHlwZS5ib3VuY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfID0gdGhpcy5zZXR0aW5ncztcbiAgdmFyIGRpciA9IF8uZGlyZWN0aW9uOyAvLyByZXZlcnNlIHRoZSBwYXJ0aWNsZSdzIFkgcG9zaXRpb25cblxuICBpZiAodGhpcy5weSA8PSAwIHx8IHRoaXMucHkgKyB0aGlzLnNpemUgPj0gdGhpcy5jYW52YXMuaGVpZ2h0KSB7XG4gICAgdGhpcy5keSA9IC10aGlzLmR5O1xuXG4gICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkge1xuICAgICAgdGhpcy5kZCA9IC10aGlzLmRkO1xuICAgIH1cbiAgfSAvLyByZXZlcnNlIHRoZSBwYXJ0aWNsZSdzIFggcG9zaXRpb25cblxuXG4gIGlmICh0aGlzLnB4IDw9IDAgfHwgdGhpcy5weCArIHRoaXMuc2l6ZSA+PSB0aGlzLmNhbnZhcy53aWR0aCkge1xuICAgIHRoaXMuZHggPSAtdGhpcy5keDtcblxuICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICB0aGlzLmRkID0gLXRoaXMuZGQ7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBjaGVjayBpZiB0aGUgcGFydGljbGUgaXMgb2ZmIHRoZSBjYW52YXMgYmFzZWRcbiAqIG9uIGl0J3MgY3VycmVudCBwb3NpdGlvblxuICogQHJldHVybnMge0Jvb2xlYW59IGlzIHRoZSBwYXJ0aWNsZSBjb21wbGV0ZWx5IG9mZiBjYW52YXNcbiAqL1xuXG5cblNwYXJ0aWNsZS5wcm90b3R5cGUuaXNPZmZDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0b3BsZWZ0ID0gMCAtIHRoaXMuc2l6ZSAqIDI7XG4gIHZhciBib3R0b20gPSB0aGlzLmNhbnZhcy5oZWlnaHQgKyB0aGlzLnNpemUgKiAyO1xuICB2YXIgcmlnaHQgPSB0aGlzLmNhbnZhcy53aWR0aCArIHRoaXMuc2l6ZSAqIDI7XG4gIHJldHVybiB0aGlzLnB4IDwgdG9wbGVmdCB8fCB0aGlzLnB4ID4gcmlnaHQgfHwgdGhpcy5weSA8IHRvcGxlZnQgfHwgdGhpcy5weSA+IGJvdHRvbTtcbn07XG4vKipcbiAqIGNoZWNrIGlmIHRoZSBwYXJ0aWNsZSBpcyB0b3VjaGluZyB0aGUgY2FudmFzIGVkZ2VcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpcyB0aGUgcGFydGljbGUgdG91Y2hpbmcgZWRnZVxuICovXG5cblxuU3BhcnRpY2xlLnByb3RvdHlwZS5pc1RvdWNoaW5nRWRnZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRvcGxlZnQgPSAwO1xuICB2YXIgYm90dG9tID0gdGhpcy5jYW52YXMuaGVpZ2h0IC0gdGhpcy5zaXplO1xuICB2YXIgcmlnaHQgPSB0aGlzLmNhbnZhcy53aWR0aCAtIHRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRoaXMucHggPCB0b3BsZWZ0IHx8IHRoaXMucHggPiByaWdodCB8fCB0aGlzLnB5IDwgdG9wbGVmdCB8fCB0aGlzLnB5ID4gYm90dG9tO1xufTtcbi8qKlxuICogZ2V0IGEgcmFuZG9tIGNvbG9yIGZvciB0aGUgcGFydGljbGUgZnJvbSB0aGVcbiAqIGFycmF5IG9mIGNvbG9ycyBzZXQgaW4gdGhlIG9wdGlvbnMgb2JqZWN0XG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIHJhbmRvbSBjb2xvciBmcm9tIGNvbG9yIGFycmF5XG4gKi9cblxuXG5TcGFydGljbGUucHJvdG90eXBlLmdldENvbG9yID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zZXR0aW5ncy5jb2xvciA9PT0gXCJyYW5kb21cIikge1xuICAgIHJldHVybiByYW5kb21BcnJheSh0aGlzLmNvbG9ycyk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnNldHRpbmdzLmNvbG9yKSkge1xuICAgIHJldHVybiByYW5kb21BcnJheSh0aGlzLnNldHRpbmdzLmNvbG9yKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5jb2xvcjtcbiAgfVxufTtcbi8qKlxuICogZ2V0IGEgcmFuZG9tIHNoYXBlIGZvciB0aGUgcGFydGljbGUgZnJvbSB0aGVcbiAqIGFycmF5IG9mIHNoYXBlcyBzZXQgaW4gdGhlIG9wdGlvbnMgb2JqZWN0XG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIHJhbmRvbSBzaGFwZSBmcm9tIHNoYXBlIGFycmF5XG4gKi9cblxuXG5TcGFydGljbGUucHJvdG90eXBlLmdldFNoYXBlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zZXR0aW5ncy5zaGFwZSA9PT0gXCJyYW5kb21cIikge1xuICAgIHJldHVybiByYW5kb21BcnJheSh0aGlzLnNoYXBlcyk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnNldHRpbmdzLnNoYXBlKSkge1xuICAgIHJldHVybiByYW5kb21BcnJheSh0aGlzLnNldHRpbmdzLnNoYXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5zaGFwZTtcbiAgfVxufTtcbi8qKlxuICogZ2V0IHRoZSBpbWFnZSBmb3IgdGhlIHBhcnRpY2xlIGZyb20gdGhlIGFycmF5XG4gKiBvZiBwb3NzaWJsZSBpbWFnZSB1cmxzXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIHJhbmRvbSBpbWFnZVVybCBmcm9tIGltYWdlVXJsIGFycmF5XG4gKi9cblxuXG5TcGFydGljbGUucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnNldHRpbmdzLmltYWdlVXJsKSkge1xuICAgIHJldHVybiByYW5kb21BcnJheSh0aGlzLnNldHRpbmdzLmltYWdlVXJsKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5pbWFnZVVybDtcbiAgfVxufTtcbi8qKlxuICogZ2V0IHRoZSBzdHlsZSBvZiB0aGUgcGFydGljbGUsIGVpdGhlciBcImZpbGxcIiBvciBcInN0cm9rZVwiXG4gKiBkZXBlbmRpbmcgb24gdGhlIHNldHRpbmdzIGFzIGZpbGwvc3Ryb2tlL2JvdGhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IC0gZWl0aGVyIFwiZmlsbFwiIG9yIFwic3Ryb2tlXCJcbiAqL1xuXG5cblNwYXJ0aWNsZS5wcm90b3R5cGUuZ2V0U3R5bGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByYW5kb21BcnJheSh0aGlzLnN0eWxlcyk7XG59O1xuLyoqXG4gKiBnZXQgYSByYW5kb20gZGVsdGEgKHZlbG9jaXR5KSBmb3IgdGhlIHBhcnRpY2xlXG4gKiBiYXNlZCBvbiB0aGUgc3BlZWQsIGFuZCB0aGUgcGFyYWxsYXggdmFsdWUgKGlmIGFwcGxpY2FibGUpXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtIHRoZSB2ZWxvY2l0eSB0byBiZSBhcHBsaWVkIHRvIHRoZSBwYXJ0aWNsZVxuICovXG5cblxuU3BhcnRpY2xlLnByb3RvdHlwZS5nZXREZWx0YSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJhc2VEZWx0YSA9IHRoaXMuc2V0dGluZ3Muc3BlZWQgKiAwLjE7XG5cbiAgaWYgKHRoaXMuc2V0dGluZ3Muc3BlZWQgJiYgdGhpcy5zZXR0aW5ncy5wYXJhbGxheCkge1xuICAgIHJldHVybiBiYXNlRGVsdGEgKyB0aGlzLnNpemUgKiB0aGlzLnNldHRpbmdzLnBhcmFsbGF4IC8gNTA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2VEZWx0YTtcbiAgfVxufTtcbi8qKlxuICogZ2V0IGEgcmFuZG9tIHZhcmlhYmxlIHNwZWVkIGZvciB1c2UgYXMgYSBtdWx0aXBsaWVyLFxuICogYmFzZWQgb24gdGhlIHZhbHVlcyBnaXZlbiBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0LCB0aGlzXG4gKiBjYW4gYmUgcG9zaXRpdmUgb3IgbmVnYXRpdmVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gYSB2YXJpYWJsZSBkZWx0YSBzcGVlZFxuICovXG5cblxuU3BhcnRpY2xlLnByb3RvdHlwZS5nZXREZWx0YVZhcmlhbmNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgdmFyIHMgPSB0aGlzLnNldHRpbmdzLnNwZWVkIHx8IDEwO1xuXG4gIGlmICh2ID4gMCkge1xuICAgIHJldHVybiByYW5kb20oLXYsIHYpICogcyAvIDEwMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcbi8qKlxuICogZ2V0IGEgcmFuZG9tIGRlbHRhIG9uIHRoZSBYIGF4aXMsIHRha2luZyBpbiB0byBhY2NvdW50XG4gKiB0aGUgdmFyaWFuY2UgcmFuZ2UgaW4gdGhlIHNldHRpbmdzIG9iamVjdCBhbmQgdGhlIHBhcnRpY2xlJ3NcbiAqIGRpcmVjdGlvbiBhcyBhIG11bHRpcGxpZXJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gdGhlIFggZGVsdGEgdG8gYmUgYXBwbGllZCB0byBwYXJ0aWNsZVxuICovXG5cblxuU3BhcnRpY2xlLnByb3RvdHlwZS5nZXREZWx0YVggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkID0gdGhpcy5nZXREZWx0YSgpO1xuICB2YXIgZHYgPSB0aGlzLmdldERlbHRhVmFyaWFuY2UodGhpcy5zZXR0aW5ncy54VmFyaWFuY2UpO1xuICByZXR1cm4gY2FydGVzaWFuKHRoaXMuc2V0dGluZ3MuZGlyZWN0aW9uKVswXSAqIGQgKyBkdjtcbn07XG4vKipcbiAqIGdldCBhIHJhbmRvbSBkZWx0YSBvbiB0aGUgWSBheGlzLCB0YWtpbmcgaW4gdG8gYWNjb3VudFxuICogdGhlIHZhcmlhbmNlIHJhbmdlIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgYW5kIHRoZSBwYXJ0aWNsZSdzXG4gKiBkaXJlY3Rpb24gYXMgYSBtdWx0aXBsaWVyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtIHRoZSBZIGRlbHRhIHRvIGJlIGFwcGxpZWQgdG8gcGFydGljbGVcbiAqL1xuXG5cblNwYXJ0aWNsZS5wcm90b3R5cGUuZ2V0RGVsdGFZID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZCA9IHRoaXMuZ2V0RGVsdGEoKTtcbiAgdmFyIGR2ID0gdGhpcy5nZXREZWx0YVZhcmlhbmNlKHRoaXMuc2V0dGluZ3MueVZhcmlhbmNlKTtcbiAgcmV0dXJuIGNhcnRlc2lhbih0aGlzLnNldHRpbmdzLmRpcmVjdGlvbilbMV0gKiBkICsgZHY7XG59O1xuLyoqXG4gKiBnZXQgYSByYW5kb20gZGVsdGEgZm9yIHRoZSBhbHBoYSBjaGFuZ2Ugb3ZlciB0aW1lIGZyb21cbiAqIGJldHdlZW4gYSBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgYWxwaGEgdmFyaWFuY2UgdmFsdWVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gdGhlIGFscGhhIGRlbHRhIHRvIGJlIGFwcGxpZWQgdG8gcGFydGljbGVcbiAqL1xuXG5cblNwYXJ0aWNsZS5wcm90b3R5cGUuZ2V0QWxwaGFEZWx0YSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZhcmlhbmNlID0gdGhpcy5zZXR0aW5ncy5hbHBoYVZhcmlhbmNlO1xuICB2YXIgYSA9IHJhbmRvbSgxLCB2YXJpYW5jZSArIDEpO1xuXG4gIGlmIChyb2xsKDEgLyAyKSkge1xuICAgIGEgPSAtYTtcbiAgfVxuXG4gIHJldHVybiBhO1xufTtcbi8qKlxuICogcmV0dXJuIGEgcmFuZG9tIGRyaWZ0IHZhbHVlIGVpdGhlciBwb3NpdGl2ZSBvciBuZWdhdGl2ZVxuICogQHJldHVybnMge051bWJlcn0gLSB0aGUgZHJpZnQgdmFsdWVcbiAqL1xuXG5cblNwYXJ0aWNsZS5wcm90b3R5cGUuZ2V0RHJpZnREZWx0YSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnNldHRpbmdzLmRyaWZ0KSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJhbmRvbSh0aGlzLnNldHRpbmdzLmRyaWZ0IC0gdGhpcy5zZXR0aW5ncy5kcmlmdCAvIDIsIHRoaXMuc2V0dGluZ3MuZHJpZnQgKyB0aGlzLnNldHRpbmdzLmRyaWZ0IC8gMik7XG4gIH1cbn07XG4vKipcbiAqIHJldHVybiBhIHJhbmRvbSByb3RhdGlvbiB2YWx1ZSBlaXRoZXIgcG9zaXRpdmUgb3IgbmVnYXRpdmVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gdGhlIHJvdGF0aW9uIHZhbHVlXG4gKi9cblxuXG5TcGFydGljbGUucHJvdG90eXBlLmdldFJvdGF0aW9uRGVsdGEgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByID0gMDtcblxuICBpZiAodGhpcy5zZXR0aW5ncy5yb3RhdGUgJiYgdGhpcy5zZXR0aW5ncy5yb3RhdGlvbikge1xuICAgIHIgPSByYWRpYW4ocmFuZG9tKDAuNSwgMS41KSAqIHRoaXMuc2V0dGluZ3Mucm90YXRpb24pO1xuXG4gICAgaWYgKHJvbGwoMSAvIDIpKSB7XG4gICAgICByID0gLXI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuLyoqXG4gKiBwcm9ncmVzcyB0aGUgcGFydGljbGUncyBmcmFtZSBudW1iZXIsIGFzIHdlbGxcbiAqIGFzIHRoZSBpbnRlcm5hbCB2YWx1ZXMgZm9yIGJvdGggdGhlIHBhcnRpY2xlJ3NcbiAqIHBvc2l0aW9uIGFuZCB0aGUgcGFydGljbGUncyBhbHBoYS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IFNwYXJ0aWNsZSBpbnN0YW5jZVxuICovXG5cblxuU3BhcnRpY2xlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZnJhbWUgKz0gMTtcbiAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICB0aGlzLnVwZGF0ZUFscGhhKCk7XG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogcHJvZ3Jlc3MgdGhlIHBhcnRpY2xlJ3MgYWxwaGEgdmFsdWUgZGVwZW5kaW5nIG9uIHRoZVxuICogYWxwaGFTcGVlZCBhbmQgdGhlIHR3aW5rbGUgc2V0dGluZ1xuICogQHJldHVybnMge051bWJlcn0gLSBuZXcgYWxwaGEgdmFsdWUgb2YgdGhlIHBhcnRpY2xlXG4gKi9cblxuXG5TcGFydGljbGUucHJvdG90eXBlLnVwZGF0ZUFscGhhID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zZXR0aW5ncy5hbHBoYVNwZWVkID4gMCkge1xuICAgIGlmICh0aGlzLnNldHRpbmdzLnR3aW5rbGUpIHtcbiAgICAgIHRoaXMuYWxwaGEgPSB0aGlzLnVwZGF0ZVR3aW5rbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hbHBoYSA9IHRoaXMudXBkYXRlRmFkZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLmFscGhhO1xufTtcbi8qKlxuICogcHJvZ3Jlc3MgdGhlIHBhcnRpY2xlJ3MgYWxwaGEgdmFsdWUgYWNjb3JkaW5nIHRvXG4gKiB0aGUgZmFkaW5nIGVmZmVjdFxuICogQHJldHVybnMge051bWJlcn0gLSBuZXcgYWxwaGEgdmFsdWUgb2YgdGhlIHBhcnRpY2xlXG4gKi9cblxuXG5TcGFydGljbGUucHJvdG90eXBlLnVwZGF0ZUZhZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aWNrID0gdGhpcy5kYSAvIDEwMDAgKiB0aGlzLnNldHRpbmdzLmFscGhhU3BlZWQgKiAwLjU7XG4gIHZhciBhbHBoYSA9IHRoaXMuYWxwaGEgKyB0aWNrO1xuICB2YXIgb3ZlciA9IHRoaXMuZGEgPiAwICYmIGFscGhhID4gdGhpcy5zZXR0aW5ncy5tYXhBbHBoYTtcbiAgdmFyIHVuZGVyID0gdGhpcy5kYSA8IDAgJiYgYWxwaGEgPCB0aGlzLnNldHRpbmdzLm1pbkFscGhhOyAvLyBpZiB0aGUgYWxwaGEgaXMgb3ZlciBvciB1bmRlciB0aGUgbWluIG9yIG1heCB2YWx1ZXMsXG4gIC8vIHRoZW4gd2UgcmV2ZXJzZSB0aGUgZGVsdGEgc28gdGhhdCBpdCBjYW4gaW5jcmVhc2Ugb3JcbiAgLy8gZGVjcmVhc2UgaW4gb3BhY2l0eSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG5cbiAgaWYgKG92ZXIgfHwgdW5kZXIpIHtcbiAgICB0aGlzLmRhID0gLXRoaXMuZGE7XG4gICAgYWxwaGEgPSB0aGlzLnNldHRpbmdzLm1heEFscGhhO1xuXG4gICAgaWYgKHVuZGVyKSB7XG4gICAgICBhbHBoYSA9IHRoaXMuc2V0dGluZ3MubWluQWxwaGE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFscGhhO1xufTtcbi8qKlxuICogcHJvZ3Jlc3MgdGhlIHBhcnRpY2xlJ3MgYWxwaGEgdmFsdWUgYWNjb3JkaW5nIHRvXG4gKiB0aGUgdHdpbmtsZSBlZmZlY3RcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gbmV3IGFscGhhIHZhbHVlIG9mIHRoZSBwYXJ0aWNsZVxuICovXG5cblxuU3BhcnRpY2xlLnByb3RvdHlwZS51cGRhdGVUd2lua2xlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYWxwaGEgPSB0aGlzLmFscGhhO1xuICB2YXIgZGVsdGEgPSBNYXRoLmFicyh0aGlzLmRhKTtcbiAgdmFyIG92ZXIgPSBhbHBoYSA+IHRoaXMuc2V0dGluZ3MubWF4QWxwaGE7XG4gIHZhciB1bmRlciA9IGFscGhhIDwgdGhpcy5zZXR0aW5ncy5taW5BbHBoYTtcbiAgdmFyIHRpY2sgPSBkZWx0YSAvIDEwMDAgKiB0aGlzLnNldHRpbmdzLmFscGhhU3BlZWQgKiAwLjU7XG4gIHZhciBmbGlja2VyT24gPSByb2xsKDEgLyAzMCk7XG4gIHZhciBmbGlja2VyT2ZmID0gcm9sbCgxIC8gMzApOyAvLyBpZiB0aGUgcGFydGljbGUgaXMgcmVzZXR0aW5nIHRoZSB0d2lua2xlIGVmZmVjdCwgdGhlblxuICAvLyB3ZSBzaW1wbHkgd2FudCB0byBxdWlja2x5IGdldCBiYWNrIHRvIG1heCBhbHBoYVxuICAvLyBvdmVyIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUsIG90aGVyd2lzZSBqdXN0IGFkdmFuY2UgdGhlIHRpY2tcblxuICBpZiAodGhpcy5yZXNldHRpbmdUd2lua2xlKSB7XG4gICAgYWxwaGEgKz0gdGljayAqIDU7XG4gIH0gZWxzZSBpZiAoZmxpY2tlck9uKSB7XG4gICAgYWxwaGEgKz0gdGljayAqIDUwO1xuICB9IGVsc2UgaWYgKGZsaWNrZXJPZmYpIHtcbiAgICBhbHBoYSAtPSB0aWNrICogMjU7XG4gIH0gZWxzZSB7XG4gICAgYWxwaGEgLT0gdGljaztcbiAgfSAvLyBvbmNlIHRoZSBhbHBoYSBpcyB1bmRlciB0aGUgbWluIGFscGhhIHZhbHVlLCB0aGVuIHdlIG5lZWRcbiAgLy8gdG8gc2V0IHRoZSB0d2lua2xlIGVmZmVjdCB0byByZXNldCwgYW5kIG9uY2UgaXQgaXMgb3ZlclxuICAvLyB0aGUgbWF4IGFscGhhLCB3ZSBzdG9wIHJlc2V0dGluZy5cblxuXG4gIGlmICh1bmRlcikge1xuICAgIHRoaXMucmVzZXR0aW5nVHdpbmtsZSA9IHRydWU7XG4gICAgYWxwaGEgPSB0aGlzLnNldHRpbmdzLm1pbkFscGhhO1xuICB9IGVsc2UgaWYgKG92ZXIpIHtcbiAgICB0aGlzLnJlc2V0dGluZ1R3aW5rbGUgPSBmYWxzZTtcbiAgICBhbHBoYSA9IHRoaXMuc2V0dGluZ3MubWF4QWxwaGE7XG4gIH1cblxuICByZXR1cm4gYWxwaGE7XG59O1xuLyoqXG4gKiBwcm9ncmVzcyB0aGUgcGFydGljbGUncyBwb3NpdGlvbiB2YWx1ZXMsIHJvdGF0aW9uIGFuZCBkcmlmdFxuICogYWNjb3JkaW5nIHRvIHRoZSBzZXR0aW5ncyBnaXZlblxuICovXG5cblxuU3BhcnRpY2xlLnByb3RvdHlwZS51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2V0dGluZ3MuYm91bmNlICYmIHRoaXMuaXNUb3VjaGluZ0VkZ2UoKSkge1xuICAgIHRoaXMuYm91bmNlKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5pc09mZkNhbnZhcygpKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMucHggKz0gdGhpcy5keDtcbiAgdGhpcy5weSArPSB0aGlzLmR5OyAvLyBkcmlmdCBtdXN0IGJlIGFwcGxpZWQgYWZ0ZXIgcG9zaXRpb24geC95XG4gIC8vIGFzIGl0IG1vZGlmaWVzIHRoZSB2YWx1ZXMgYnkgd2F2ZSBmdW5jdGlvblxuXG4gIHRoaXMudXBkYXRlRHJpZnQoKTtcbiAgdGhpcy51cGRhdGVSb3RhdGlvbigpO1xufTtcbi8qKlxuICogcHJvZ3Jlc3MgdGhlIHBhcnRpY2xlJ3Mgcm90YXRpb24gdmFsdWUgYWNjb3JkaW5nXG4gKiB0byB0aGUgc2V0dGluZ3MgZ2l2ZW5cbiAqL1xuXG5cblNwYXJ0aWNsZS5wcm90b3R5cGUudXBkYXRlUm90YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNldHRpbmdzLnJvdGF0ZSAmJiB0aGlzLnNldHRpbmdzLnJvdGF0aW9uKSB7XG4gICAgdGhpcy5yb3RhdGlvbiArPSB0aGlzLmRyO1xuICB9XG59O1xuLyoqXG4gKiBwcm9ncmVzcyB0aGUgcGFydGljbGUncyBkcmlmdCB2YWx1ZSBhY2NvcmRpbmdcbiAqIHRvIHRoZSBzZXR0aW5ncyBnaXZlblxuICovXG5cblxuU3BhcnRpY2xlLnByb3RvdHlwZS51cGRhdGVEcmlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF8gPSB0aGlzLnNldHRpbmdzO1xuICB2YXIgZGlyID0gXy5kaXJlY3Rpb247XG5cbiAgaWYgKF8uZHJpZnQgJiYgXy5zcGVlZCkge1xuICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAvLyBhcHBseSBIT1JJWk9OVEFMIGRyaWZ0IH4gd2hlbiBcImRpcmVjdGlvblwiIGlzIG1vc3RseSB2ZXJ0aWNhbC5cbiAgICAgIHRoaXMucHggKz0gY2FydGVzaWFuKHRoaXMuZnJhbWUgKyB0aGlzLmZyYW1lb2Zmc2V0KVswXSAqIHRoaXMuZGQgLyAodGhpcy5nZXREZWx0YSgpICogMTUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAvLyBhcHBseSBWRVJUSUNBTCBkcmlmdCB+IHdoZW4gXCJkaXJlY3Rpb25cIiBpcyBtb3N0bHkgaG9yaXpvbnRhbC5cbiAgICAgIHRoaXMucHkgKz0gY2FydGVzaWFuKHRoaXMuZnJhbWUgKyB0aGlzLmZyYW1lb2Zmc2V0KVsxXSAqIHRoaXMuZGQgLyAodGhpcy5nZXREZWx0YSgpICogMTUpO1xuICAgIH1cbiAgfVxufTtcblxuU3BhcnRpY2xlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY2FudmFzc2VzKSB7XG4gIHZhciBwYXJ0aWNsZUNhbnZhcztcblxuICBpZiAodGhpcy5zaGFwZSAhPT0gXCJpbWFnZVwiKSB7XG4gICAgcGFydGljbGVDYW52YXMgPSBjYW52YXNzZXNbdGhpcy5jb2xvcl1bdGhpcy5zaGFwZV1bdGhpcy5zdHlsZV07XG4gIH0gZWxzZSB7XG4gICAgcGFydGljbGVDYW52YXMgPSBjYW52YXNzZXNbdGhpcy5jb2xvcl1bdGhpcy5zaGFwZV1bdGhpcy5pbWFnZV07XG4gIH1cblxuICB2YXIgY2FudmFzU2l6ZSA9IHBhcnRpY2xlQ2FudmFzLndpZHRoO1xuICB2YXIgc2NhbGUgPSB0aGlzLnNpemUgLyBjYW52YXNTaXplO1xuICB2YXIgcHggPSB0aGlzLnB4IC8gc2NhbGU7XG4gIHZhciBweSA9IHRoaXMucHkgLyBzY2FsZTtcbiAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSBjbGFtcCh0aGlzLmFscGhhLCAwLCAxKTtcbiAgdGhpcy5yZW5kZXJSb3RhdGUoKTtcbiAgdGhpcy5jdHgudHJhbnNmb3JtKHNjYWxlLCAwLCAwLCBzY2FsZSwgMCwgMCk7XG4gIHRoaXMuY3R4LmRyYXdJbWFnZShwYXJ0aWNsZUNhbnZhcywgMCwgMCwgY2FudmFzU2l6ZSwgY2FudmFzU2l6ZSwgcHgsIHB5LCBjYW52YXNTaXplLCBjYW52YXNTaXplKTtcbiAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICByZXR1cm4gdGhpcztcbn07XG5cblNwYXJ0aWNsZS5wcm90b3R5cGUucmVuZGVyUm90YXRlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zaGFwZSAhPT0gXCJjaXJjbGVcIiAmJiB0aGlzLnNldHRpbmdzLnJvdGF0ZSkge1xuICAgIHZhciBjZW50ZXJYID0gdGhpcy5weCArIHRoaXMuc2l6ZSAvIDI7XG4gICAgdmFyIGNlbnRlclkgPSB0aGlzLnB5ICsgdGhpcy5zaXplIC8gMjtcbiAgICB0aGlzLmN0eC50cmFuc2xhdGUoY2VudGVyWCwgY2VudGVyWSk7XG4gICAgdGhpcy5jdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xuICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSgtY2VudGVyWCwgLWNlbnRlclkpO1xuICB9XG59O1xuXG4vKipcbiAqIFNwYXJ0aWNsZXMgQ29uc3RydWN0b3I7XG4gKiBDcmVhdGUgYSA8Y2FudmFzPiwgYXBwZW5kIHRvIHRoZSBnaXZlbiBub2RlLCBhbmQgc3RhcnQgdGhlIHBhcnRpY2xlIGVmZmVjdFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW25vZGU9ZG9jdW1lbnQuYm9keV0gLSBlbGVtZW50IHRvIHdoaWNoIGNhbnZhcyBpcyBhcHBlbmRlZCB0b1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIHNldHRpbmdzIHRvIHVzZSBmb3IgdGhlIHBhcnRpY2xlIGVmZmVjdFxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbXBvc2l0aW9uPXNvdXJjZS1vdmVyXSAtIGNhbnZhcyBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gdmFsdWUgZm9yIHBhcnRpY2xlc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvdW50PTUwXSAtIG51bWJlciBvZiBwYXJ0aWNsZXMgb24gdGhlIGNhbnZhcyBzaW11bHRhbmVvdXNseVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNwZWVkPTEwXSAtIGRlZmF1bHQgdmVsb2NpdHkgb2YgZXZlcnkgcGFydGljbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wYXJhbGxheD0xXSAtIHNwZWVkIG11bHRpcGxpZXIgZWZmZWN0IGZvciBsYXJnZXIgcGFydGljbGVzICgwID0gbm9uZSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kaXJlY3Rpb249MTgwXSAtIGRlZmF1bHQgZGlyZWN0aW9uIG9mIHBhcnRpY2xlcyBpbiBkZWdyZWVzICgwID0g4oaRLCAxODAgPSDihpMpXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMueFZhcmlhbmNlPTJdIC0gcmFuZG9tIGRldmlhdGlvbiBvZiBwYXJ0aWNsZXMgb24geC1heGlzIGZyb20gZGVmYXVsdCBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy55VmFyaWFuY2U9Ml0gLSByYW5kb20gZGV2aWF0aW9uIG9mIHBhcnRpY2xlcyBvbiB5LWF4aXMgZnJvbSBkZWZhdWx0IGRpcmVjdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJvdGF0ZT10cnVlXSAtIGNhbiBwYXJ0aWNsZXMgcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucm90YXRpb249MV0gLSBkZWZhdWx0IHJvdGF0aW9uYWwgc3BlZWQgZm9yIGV2ZXJ5IHBhcnRpY2xlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYWxwaGFTcGVlZD0xMF0gLSByYXRlIG9mIGNoYW5nZSBpbiBhbHBoYSBvdmVyIHRpbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hbHBoYVZhcmlhbmNlPTFdIC0gcmFuZG9tIGRldmlhdGlvbiBvZiBhbHBoYSBjaGFuZ2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5BbHBoYT0wXSAtIG1pbnVtdW0gYWxwaGEgdmFsdWUgb2YgZXZlcnkgcGFydGljbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhBbHBoYT0xXSAtIG1heGltdW0gYWxwaGEgdmFsdWUgb2YgZXZlcnkgcGFydGljbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5TaXplPTFdIC0gbWluaW11bSBzaXplIG9mIGV2ZXJ5IHBhcnRpY2xlXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4U2l6ZT0xMF0gLSBtYXhpbXVtIHNpemUgb2YgZXZlcnkgcGFydGljbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYm91bmNlPWZhbHNlXSAtIHNob3VsZCB0aGUgcGFydGljbGVzIGJvdW5jZSBvZmYgZWRnZSBvZiBjYW52YXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kcmlmdD0xXSAtIHRoZSBcImRyaWZ0aW5lc3NcIiBvZiBwYXJ0aWNsZXMgd2hpY2ggaGF2ZSBhIGhvcml6b250YWwvdmVydGljYWwgZGlyZWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZ2xvdz0wXSAtIHRoZSBnbG93IGVmZmVjdCBzaXplIG9mIGVhY2ggcGFydGljbGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHdpbmtsZT1mYWxzZV0gLSBwYXJ0aWNsZXMgdG8gZXhoaWJpdCBhbiBhbHRlcm5hdGl2ZSBhbHBoYSB0cmFuc2l0aW9uIGFzIFwidHdpbmtsaW5nXCJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdHlsZT1maWxsXSAtIGZpbGwgc3R5bGUgb2YgcGFydGljbGVzIChvbmUgb2Y7IFwiZmlsbFwiLCBcInN0cm9rZVwiIG9yIFwiYm90aFwiKVxuICogQHBhcmFtIHsoU3RyaW5nfFN0cmluZ1tdKX0gW29wdGlvbnMuc2hhcGU9Y2lyY2xlXSAtIHNoYXBlIG9mIHBhcnRpY2xlcyAoYW55IG9mOyBjaXJjbGUsIHNxdWFyZSwgdHJpYW5nbGUsIGRpYW1vbmQsIGxpbmUsIGltYWdlKSBvciBcInJhbmRvbVwiXG4gKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBbb3B0aW9ucy5pbWFnZVVybD1dIC0gaWYgc2hhcGUgaXMgXCJpbWFnZVwiLCBkZWZpbmUgYW4gaW1hZ2UgdXJsIChjYW4gYmUgZGF0YS11cmksIG11c3QgYmUgc3F1YXJlICgxOjEgcmF0aW8pKVxuICogQHBhcmFtIHsoU3RyaW5nfFN0cmluZ1tdKX0gW29wdGlvbnMuY29sb3I9cmFuZG9tXSAtIGNzcyBjb2xvciBhcyBzdHJpbmcsIG9yIGFycmF5IG9mIGNvbG9yIHN0cmluZ3MgKGNhbiBhbHNvIGJlIFwicmFuZG9tXCIpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5yYW5kb21Db2xvcj1yYW5kb21Ic2woaW5kZXgsdG90YWwpXSAtIGEgY3VzdG9tIGZ1bmN0aW9uIGZvciBzZXR0aW5nIHRoZSByYW5kb20gY29sb3JzIHdoZW4gY29sb3I9XCJyYW5kb21cIlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJhbmRvbUNvbG9yQ291bnQ9M10gLSB0aGUgbnVtYmVyIG9mIHJhbmRvbSBjb2xvcnMgdG8gZ2VuZXJhdGUgd2hlbiBjb2xvciBpcyBcInJhbmRvbVwiXG4gKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoXSAtIHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIGVsZW1lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PXdpZHRoXSAtIHRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhcyBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIHJlZmVyZW5jZSB0byBhIG5ldyBTcGFydGljbGVzIGluc3RhbmNlXG4gKi9cblxudmFyIFNwYXJ0aWNsZXMgPSBmdW5jdGlvbiBTcGFydGljbGVzKG5vZGUsIG9wdGlvbnMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMSAmJiAhKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgd2lkdGggPSBhcmd1bWVudHNbMV07XG4gICAgaGVpZ2h0ID0gYXJndW1lbnRzWzJdO1xuICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAod2lkdGggJiYgIWhlaWdodCkge1xuICAgIGhlaWdodCA9IHdpZHRoO1xuICB9XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGFscGhhU3BlZWQ6IDEwLFxuICAgIGFscGhhVmFyaWFuY2U6IDEsXG4gICAgYm91bmNlOiBmYWxzZSxcbiAgICBjb2xvcjogXCJyYW5kb21cIixcbiAgICByYW5kb21Db2xvcjogcmFuZG9tSHNsLFxuICAgIHJhbmRvbUNvbG9yQ291bnQ6IDMsXG4gICAgY29tcG9zaXRpb246IFwic291cmNlLW92ZXJcIixcbiAgICBjb3VudDogNTAsXG4gICAgZGlyZWN0aW9uOiAxODAsXG4gICAgZHJpZnQ6IDEsXG4gICAgZ2xvdzogMCxcbiAgICBpbWFnZVVybDogXCJcIixcbiAgICBtYXhBbHBoYTogMSxcbiAgICBtYXhTaXplOiAxMCxcbiAgICBtaW5BbHBoYTogMCxcbiAgICBtaW5TaXplOiAxLFxuICAgIHBhcmFsbGF4OiAxLFxuICAgIHJvdGF0ZTogdHJ1ZSxcbiAgICByb3RhdGlvbjogMSxcbiAgICBzaGFwZTogXCJjaXJjbGVcIixcbiAgICBzcGVlZDogMTAsXG4gICAgc3R5bGU6IFwiZmlsbFwiLFxuICAgIHR3aW5rbGU6IGZhbHNlLFxuICAgIHhWYXJpYW5jZTogMixcbiAgICB5VmFyaWFuY2U6IDJcbiAgfTtcbiAgdGhpcy5lbCA9IG5vZGUgfHwgZG9jdW1lbnQuYm9keTtcbiAgdGhpcy5zZXR0aW5ncyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0cyksIG9wdGlvbnMpO1xuICB0aGlzLnJlc2l6YWJsZSA9ICF3aWR0aCAmJiAhaGVpZ2h0O1xuICB0aGlzLndpZHRoID0gdGhpcy5yZXNpemFibGUgPyB0aGlzLmVsLmNsaWVudFdpZHRoIDogd2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gdGhpcy5yZXNpemFibGUgPyB0aGlzLmVsLmNsaWVudEhlaWdodCA6IGhlaWdodDtcbiAgLyoqXG4gICAqIGluaXRpYWxpc2UgdGhlIHNwYXJ0aWNsZXMgaW5zdGFuY2VcbiAgICogQHJldHVybnMge09iamVjdH0gLSByZWZlcmVuY2UgdG8gdGhlIFNwYXJ0aWNsZXMgaW5zdGFuY2VcbiAgICovXG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLnNwYXJ0aWNsZXMgPSBbXTtcbiAgICB0aGlzLmNvbG9ycyA9IHRoaXMuZ2V0Q29sb3JBcnJheSgpO1xuICAgIHRoaXMuc2hhcGVzID0gdGhpcy5nZXRTaGFwZUFycmF5KCk7XG4gICAgdGhpcy5zdHlsZXMgPSB0aGlzLmdldFN0eWxlQXJyYXkoKTtcbiAgICB0aGlzLmltYWdlVXJscyA9IHRoaXMuZ2V0SW1hZ2VBcnJheSgpO1xuICAgIHRoaXMuc2V0dXBNYWluQ2FudmFzKCk7XG4gICAgdGhpcy5zZXR1cE9mZnNjcmVlbkNhbnZhc3NlcyhmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5jcmVhdGVTcGFydGljbGVzKCk7XG5cbiAgICAgIF90aGlzLnN0YXJ0KCk7XG4gICAgfSk7IC8vIGRlZmVyIHRvIHRoZSBkZWZhdWx0IFwiaGFuZGxlRXZlbnRcIiBoYW5kbGVyXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50TGlzdGVuZXIvaGFuZGxlRXZlbnRcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogaGFuZGxlIGV2ZW50IGZvciBzY3JlZW4gcmVzaXplO1xuICAgKiBkZWJvdW5jZSBhIGNhbnZhcyByZXNpemUsXG4gICAqIHJlc2V0IHRoZSBwYXJ0aWNsZXNcbiAgICovXG5cblxuICB0aGlzLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJyZXNpemVcIikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZXIpO1xuICAgICAgdGhpcy5yZXNpemVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMyLnJlc2l6YWJsZSkge1xuICAgICAgICAgIF90aGlzMi53aWR0aCA9IF90aGlzMi5lbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICBfdGhpczIuaGVpZ2h0ID0gX3RoaXMyLmVsLmNsaWVudEhlaWdodDtcblxuICAgICAgICAgIF90aGlzMi5zZXRDYW52YXNTaXplKCkucmVzZXRTcGFydGljbGVzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDIwMCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogc3RhcnQvcmVzdW1lIHRoZSBzcGFydGljbGVzIGFuaW1hdGlvblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIHRoZSBTcGFydGljbGUgaW5zdGFuY2UgKGZvciBjaGFpbmluZylcbiAgICovXG5cblxuICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMubG9vcCkge1xuICAgICAgdGhpcy5sb29wID0gbmV3IEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIG1lLmRyYXdGcmFtZSh0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMubG9vcC5zdGFydCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogc3RvcC9wYXVzZSB0aGUgc3BhcnRpY2xlcyBhbmltYXRpb25cbiAgICogQHJldHVybnMge09iamVjdH0gLSB0aGUgU3BhcnRpY2xlIGluc3RhbmNlIChmb3IgY2hhaW5pbmcpXG4gICAqL1xuXG5cbiAgdGhpcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubG9vcC5zdG9wKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBkZXN0cm95IHRoZSBjdXJyZW50IGluc3RhbmNlIGFuZCBmcmVlIHVwIHNvbWUgbWVtb3J5XG4gICAqIEByZXR1cm5zIHtPYmplY3R9IC0gdGhlIFNwYXJ0aWNsZSBpbnN0YW5jZSAoZm9yIGNoYWluaW5nKVxuICAgKi9cblxuXG4gIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzdG9wIHRoZSByZW5kZXJpbmcgYW5kIHVwZGF0aW5nXG4gICAgdGhpcy5zdG9wKCk7IC8vIHJlbW92ZSB0aGUgY2FudmFzIGVsZW1lbnQgZnJvbSB0aGUgRE9NXG5cbiAgICB0aGlzLmVsLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTsgLy8gcmVtb3ZlIHRoZSByZXNpemUgZXZlbnQgZm9yIHRoaXMgaW5zdGFuY2VcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMpOyAvLyBkZWxldGUgYWxsIHRoZSBwcm9wZXJ0aWVzIGZyb20gdGhlIGluc3RhbmNlXG4gICAgLy8gdG8gZnJlZSB1cCBtZW1vcnlcblxuICAgIGZvciAodmFyIHByb3AgaW4gdGhpcykge1xuICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNbcHJvcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBzZXQgdGhlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IG9mIHRoZSBjYW52YXNcbiAgICogQHJldHVybnMge09iamVjdH0gLSB0aGUgU3BhcnRpY2xlIGluc3RhbmNlIChmb3IgY2hhaW5pbmcpXG4gICAqL1xuXG5cbiAgdGhpcy5zZXRDYW52YXNTaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAod2lkdGgpIHtcbiAgICAgIHRoaXMucmVzaXphYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IHRoaXMud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogY3JlYXRlIGFuIGFycmF5IGFuZCBwb3B1bGF0ZSBpdCB3aXRoIG5ldyBTcGFydGljbGUgaW5zdGFuY2VzLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSBhcnJheSBvZiBTcGFydGljbGUgaW5zdGFuY2VzXG4gICAqL1xuXG5cbiAgdGhpcy5yZXNldFNwYXJ0aWNsZXMgPSB0aGlzLmNyZWF0ZVNwYXJ0aWNsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zcGFydGljbGVzID0gW107XG4gICAgdGhpcy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5zZXR0aW5ncy5jb21wb3NpdGlvbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZXR0aW5ncy5jb3VudDsgaSsrKSB7XG4gICAgICB0aGlzLnNwYXJ0aWNsZXMucHVzaChuZXcgU3BhcnRpY2xlKHRoaXMsIGkpKTtcbiAgICB9XG5cbiAgICB0aGlzLnNvcnQoKTtcbiAgICByZXR1cm4gdGhpcy5zcGFydGljbGVzO1xuICB9O1xuICAvKipcbiAgICogc29ydCB0aGUgcGFydGljbGUgYXJyYXkgYnkgc2l6ZSBzbyB0aGF0IHBhcmFsbGF4IGVmZmVjdFxuICAgKiBkb2Vzbid0IGFwcGVhciB0byBoYXZlIHNsb3dlci9zbWFsbGVyIHBhcnRpY2xlcyBpbiBmb3JlZ3JvdW5kXG4gICAqL1xuXG5cbiAgdGhpcy5zb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnNldHRpbmdzLnBhcmFsbGF4KSB7XG4gICAgICB0aGlzLnNwYXJ0aWNsZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5zaXplIC0gYi5zaXplO1xuICAgICAgfSk7XG4gICAgfVxuICB9OyAvLyBpbml0aWFsaXNlIHRoZSBzcGFydGljbGVzLCBhbmQgcmV0dXJuIHRoZSBpbnN0YW5jZS5cblxuXG4gIHJldHVybiB0aGlzLmluaXQoKTtcbn07XG4vKipcbiAqIGNvbnZlcnQgdGhlIGlucHV0IGNvbG9yIHRvIGFuIGFycmF5IGlmIGl0IGlzbid0IGFscmVhZHlcbiAqIEByZXR1cm5zIHtBcnJheX0gLSBhcnJheSBvZiBjb2xvcnMgZm9yIHVzZSBpbiByZW5kZXJpbmdcbiAqL1xuXG5cblNwYXJ0aWNsZXMucHJvdG90eXBlLmdldENvbG9yQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb2xvcnMgPSBBcnJheS5pc0FycmF5KHRoaXMuc2V0dGluZ3MuY29sb3IpID8gdGhpcy5zZXR0aW5ncy5jb2xvciA6IFt0aGlzLnNldHRpbmdzLmNvbG9yXTtcbiAgdmFyIGlzUmFuZG9tID0gY29sb3JzLnNvbWUoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gYyA9PT0gXCJyYW5kb21cIjtcbiAgfSk7XG5cbiAgaWYgKGlzUmFuZG9tKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNldHRpbmdzLnJhbmRvbUNvbG9yQ291bnQ7IGkrKykge1xuICAgICAgY29sb3JzW2ldID0gdGhpcy5zZXR0aW5ncy5yYW5kb21Db2xvcihpLCB0aGlzLnNldHRpbmdzLnJhbmRvbUNvbG9yQ291bnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb2xvcnM7XG59O1xuLyoqXG4gKiBjb252ZXJ0IHRoZSBpbnB1dCBzaGFwZSB0byBhbiBhcnJheSBpZiBpdCBpc24ndCBhbHJlYWR5XG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gYXJyYXkgb2Ygc2hhcGVzIGZvciB1c2UgaW4gcmVuZGVyaW5nXG4gKi9cblxuXG5TcGFydGljbGVzLnByb3RvdHlwZS5nZXRTaGFwZUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2hhcGVzID0gQXJyYXkuaXNBcnJheSh0aGlzLnNldHRpbmdzLnNoYXBlKSA/IHRoaXMuc2V0dGluZ3Muc2hhcGUgOiBbdGhpcy5zZXR0aW5ncy5zaGFwZV07XG4gIHZhciBpc1JhbmRvbSA9IHNoYXBlcy5zb21lKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIGMgPT09IFwicmFuZG9tXCI7XG4gIH0pO1xuXG4gIGlmIChpc1JhbmRvbSkge1xuICAgIHNoYXBlcyA9IFtcInNxdWFyZVwiLCBcImNpcmNsZVwiLCBcInRyaWFuZ2xlXCJdO1xuICB9XG5cbiAgcmV0dXJuIHNoYXBlcztcbn07XG4vKipcbiAqIGNvbnZlcnQgdGhlIGltYWdlVXJsIG9wdGlvbiB0byBhbiBhcnJheSBpZiBpdCBpc24ndCBhbHJlYWR5XG4gKiBAcmV0dXJucyB7QXJyYXl9IC0gYXJyYXkgb2YgaW1hZ2UgdXJscyBmb3IgdXNlIGluIHJlbmRlcmluZ1xuICovXG5cblxuU3BhcnRpY2xlcy5wcm90b3R5cGUuZ2V0SW1hZ2VBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpcy5zZXR0aW5ncy5pbWFnZVVybCkgPyB0aGlzLnNldHRpbmdzLmltYWdlVXJsIDogW3RoaXMuc2V0dGluZ3MuaW1hZ2VVcmxdO1xufTtcbi8qKlxuICogY29udmVydCB0aGUgaW5wdXQgc3R5bGUgdG8gYW4gYXJyYXlcbiAqIEByZXR1cm5zIHtBcnJheX0gLSBhcnJheSBvZiBzdHlsZXMgZm9yIHVzZSBpbiByZW5kZXJpbmdcbiAqL1xuXG5cblNwYXJ0aWNsZXMucHJvdG90eXBlLmdldFN0eWxlQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHlsZXMgPSB0aGlzLnNldHRpbmdzLnN0eWxlO1xuXG4gIGlmIChzdHlsZXMgIT09IFwiZmlsbFwiICYmIHN0eWxlcyAhPT0gXCJzdHJva2VcIikge1xuICAgIHN0eWxlcyA9IFtcImZpbGxcIiwgXCJzdHJva2VcIl07XG4gIH0gZWxzZSB7XG4gICAgc3R5bGVzID0gW3N0eWxlc107XG4gIH1cblxuICByZXR1cm4gc3R5bGVzO1xufTtcbi8qKlxuICogc2V0IHVwIHRoZSBjYW52YXMgYW5kIGJpbmQgdG8gYSBwcm9wZXJ0eSBmb3JcbiAqIGFjY2VzcyBsYXRlciBvbiwgYXBwZW5kIGl0IHRvIHRoZSBET01cbiAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH0gLSB0aGUgY2FudmFzIGVsZW1lbnQgd2hpY2ggd2FzIGFwcGVuZGVkIHRvIERPTVxuICovXG5cblxuU3BhcnRpY2xlcy5wcm90b3R5cGUuc2V0dXBNYWluQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwic3BhcnRpY2xlc1wiKTtcbiAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIHRoaXMuc2V0Q2FudmFzU2l6ZSgpO1xuICB0aGlzLmVsLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcbiAgcmV0dXJuIHRoaXMuY2FudmFzO1xufTtcbi8qKlxuICogY3JlYXRlIGEgbmV3IG9mZnNjcmVlbiBjYW52YXMgZWxlbWVudCBmb3IgZWFjaCBjb2xvciAmIHNoYXBlXG4gKiBjb21iaW5hdGlvbiwgc28gdGhhdCB3ZSBjYW4gcmVmZXJlbmNlIGl0IGxhdGVyIGR1cmluZyByZW5kZXJcbiAqIChodWdlIHBlcmZvcm1hbmNlIGdhaW5zIGhlcmUpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciBpbWFnZSBsb2Fkc1xuICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fSAtIHRoZSBjcmVhdGVkIG9mZnNjcmVlbiBjYW52YXNcbiAqL1xuXG5cblNwYXJ0aWNsZXMucHJvdG90eXBlLnNldHVwT2Zmc2NyZWVuQ2FudmFzc2VzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gIHZhciBjb2xvcnMgPSB0aGlzLmNvbG9ycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuIF90aGlzMy5jb2xvcnMuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXg7XG4gIH0pO1xuICB2YXIgc2hhcGVzID0gdGhpcy5zaGFwZXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiBfdGhpczMuc2hhcGVzLmluZGV4T2YoaXRlbSkgPT09IGluZGV4O1xuICB9KTtcbiAgdmFyIHN0eWxlcyA9IHRoaXMuc3R5bGVzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICByZXR1cm4gX3RoaXMzLnN0eWxlcy5pbmRleE9mKGl0ZW0pID09PSBpbmRleDtcbiAgfSk7XG4gIHZhciBpbWFnZVVybHMgPSB0aGlzLmltYWdlVXJscy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuIF90aGlzMy5pbWFnZVVybHMuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXg7XG4gIH0pO1xuICB2YXIgaW1hZ2VDb3VudCA9IGNvbG9ycy5sZW5ndGggKiBpbWFnZVVybHMubGVuZ3RoO1xuICB2YXIgY2FudmFzQ291bnQgPSBjb2xvcnMubGVuZ3RoICogc2hhcGVzLmxlbmd0aCAqIHN0eWxlcy5sZW5ndGg7XG4gIHZhciBpbWFnZXNMb2FkZWQgPSAwO1xuICB2YXIgY2FudmFzc2VzQ3JlYXRlZCA9IDA7XG4gIHRoaXMuY2FudmFzc2VzID0gdGhpcy5jYW52YXNzZXMgfHwge307XG4gIGNvbG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChjb2xvcikge1xuICAgIF90aGlzMy5jYW52YXNzZXNbY29sb3JdID0gX3RoaXMzLmNhbnZhc3Nlc1tjb2xvcl0gfHwge307XG4gICAgc2hhcGVzLmZvckVhY2goZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICBfdGhpczMuY2FudmFzc2VzW2NvbG9yXVtzaGFwZV0gPSBfdGhpczMuY2FudmFzc2VzW2NvbG9yXVtzaGFwZV0gfHwge307XG5cbiAgICAgIGlmIChzaGFwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICAgIGltYWdlVXJscy5mb3JFYWNoKGZ1bmN0aW9uIChpbWFnZVVybCwgaSkge1xuICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgIHZhciBpbWFnZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgX3RoaXMzLmNhbnZhc3Nlc1tjb2xvcl1bc2hhcGVdW2ltYWdlVXJsXSA9IGltYWdlQ2FudmFzO1xuXG4gICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW1hZ2VzTG9hZGVkKys7XG5cbiAgICAgICAgICAgIF90aGlzMy5kcmF3T2Zmc2NyZWVuQ2FudmFzRm9ySW1hZ2UoaW1hZ2UsIGNvbG9yLCBpbWFnZUNhbnZhcyk7XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBpbWFnZXNMb2FkZWQgPT09IGltYWdlQ291bnQpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJmYWlsZWQgdG8gbG9hZCBzb3VyY2UgaW1hZ2U6IFwiLCBpbWFnZVVybCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGltYWdlLnNyYyA9IGltYWdlVXJsO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgIF90aGlzMy5jYW52YXNzZXNbY29sb3JdW3NoYXBlXVtzdHlsZV0gPSBjYW52YXM7XG4gICAgICAgICAgY2FudmFzc2VzQ3JlYXRlZCsrO1xuXG4gICAgICAgICAgX3RoaXMzLmRyYXdPZmZzY3JlZW5DYW52YXMoc2hhcGUsIHN0eWxlLCBjb2xvciwgY2FudmFzKTtcblxuICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBjYW52YXNzZXNDcmVhdGVkID09PSBjYW52YXNDb3VudCkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG4vKipcbiAqIHJldHVybiB0aGUgc2l6ZSBvZiB0aGUgZ2xvdyBlZmZlY3QgKHNoYWRvd0JsdXIpIGZvciBlYWNoIHBhcnRpY2xlXG4gKiBAcGFyYW0ge051bWJlcn0gc2l6ZSAtIHRoZSBzaXplIG9mIHRoZSBwYXJ0aWNsZVxuICogQHJldHVybnMge051bWJlcn0gLSB0aGUgc2l6ZSBvZiB0aGUgZ2xvdy9zaGFkb3dcbiAqL1xuXG5cblNwYXJ0aWNsZXMucHJvdG90eXBlLmdldEdsb3dTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIHRoaXMuc2V0dGluZ3MuZ2xvdztcbn07XG4vKipcbiAqIHJldHVybiB0aGUgb3V0bGluZSBvciBzdHJva2Ugc2l6ZSBvZiBlYWNoIHBhcnRpY2xlXG4gKiBAcGFyYW0ge051bWJlcn0gc2l6ZSAtIHRoZSBzaXplIG9mIHRoZSBwYXJ0aWNsZVxuICogQHJldHVybnMge051bWJlcn0gLSB0aGUgc2l6ZSBvZiB0aGUgb3V0bGluZS9zdHJva2VcbiAqL1xuXG5cblNwYXJ0aWNsZXMucHJvdG90eXBlLmdldExpbmVTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGNsYW1wKHNpemUgLyAyMCwgMSwgNSk7XG59O1xuLyoqXG4gKiByZXR1cm4gdGhlIG9mZnNjcmVlbkNhbnZhcyBzaXplIHRvIGdlbmVyYXRlIGZvclxuICogQHJldHVybnMge051bWJlcn0gLSB0aGUgbWF4U2l6ZSBvZiB0aGUgb2Zmc2NyZWVuIGNhbnZhc1xuICovXG5cblxuU3BhcnRpY2xlcy5wcm90b3R5cGUuZ2V0T2Zmc2NyZWVuQ2FudmFzU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNsYW1wKHRoaXMuc2V0dGluZ3MubWF4U2l6ZSwgdGhpcy5zZXR0aW5ncy5taW5TaXplLCB0aGlzLnNldHRpbmdzLm1heFNpemUpO1xufTtcbi8qKlxuICogc2V0IHRoZSBmaWxsL3N0cm9rZSBzdHlsZSAoY29sb3IgJiB3aWR0aCkgZm9yIGVhY2ggcGFydGljbGUncyBvZmZzY3JlZW4gY2FudmFzXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gdGhlIGNhbnZhcyBjb250ZXh0XG4gKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgLSB0aGUgY29sb3IgdG8gZmlsbC9zdHJva2Ugd2l0aFxuICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVTaXplIC0gc2l6ZS90aGlja25lc3Mgb2YgdGhlIHN0cm9rZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0eWxlIC0gc3R5bGUgKGVpdGhlciBcImZpbGxcIiBvciBcInN0cm9rZVwiKVxuICovXG5cblxuU3BhcnRpY2xlcy5wcm90b3R5cGUucmVuZGVyU3R5bGUgPSBmdW5jdGlvbiAoY3R4LCBjb2xvciwgbGluZVNpemUsIHN0eWxlKSB7XG4gIGlmIChzdHlsZSA9PT0gXCJmaWxsXCIpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVTaXplO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICB9XG59O1xuLyoqXG4gKiBzZXQgdGhlIHNoYWRvd0JsdXIgKGdsb3cgZWZmZWN0KSBmb3IgZWFjaCBwYXJ0aWNsZSdzIG9mZnNjcmVlbiBjYW52YXNcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSB0aGUgY2FudmFzIGNvbnRleHRcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciAtIHRoZSBjb2xvciB0byBmaWxsL3N0cm9rZSB3aXRoXG4gKiBAcGFyYW0ge051bWJlcn0gc2l6ZSAtIHNpemUgb2YgdGhlIHNoYWRvdy9nbG93XG4gKi9cblxuXG5TcGFydGljbGVzLnByb3RvdHlwZS5yZW5kZXJHbG93ID0gZnVuY3Rpb24gKGN0eCwgY29sb3IsIHNpemUpIHtcbiAgdmFyIGdsb3dTaXplID0gdGhpcy5nZXRHbG93U2l6ZShzaXplKSAvIDI7XG4gIGN0eC5zaGFkb3dDb2xvciA9IGNvbG9yO1xuICBjdHguc2hhZG93Qmx1ciA9IGdsb3dTaXplO1xufTtcbi8qKlxuICogZmlsbCBvciBzdHJva2UgZWFjaCBwYXJ0aWNsZSdzIG9mZnNjcmVlbiBjYW52YXMgZGVwZW5kaW5nIG9uIHRoZSBnaXZlbiBzZXR0aW5nXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gdGhlIGNhbnZhcyBjb250ZXh0XG4gKiBAcGFyYW0ge1N0cmluZ30gc3R5bGUgLSBzdHlsZSAoZWl0aGVyIFwiZmlsbFwiIG9yIFwic3Ryb2tlXCIpXG4gKi9cblxuXG5TcGFydGljbGVzLnByb3RvdHlwZS5yZW5kZXJDb2xvciA9IGZ1bmN0aW9uIChjdHgsIHN0eWxlLCBwYXRoKSB7XG4gIGlmIChzdHlsZSA9PT0gXCJmaWxsXCIpIHtcbiAgICBpZiAocGF0aCkge1xuICAgICAgY3R4LmZpbGwocGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwYXRoKSB7XG4gICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBwYXNzLXRocm91Z2ggdGhlIG5lZWRlZCBwYXJhbWV0ZXJzIHRvIHRoZSBvZmZzY3JlZW4gY2FudmFzXG4gKiBkcmF3IGZ1bmN0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gc2hhcGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaGFwZSAtICBzaGFwZSBvZiB0aGUgY2FudmFzIHRvIGRyYXcgKGVnOiBcImNpcmNsZVwiKVxuICogQHBhcmFtIHtTdHJpbmd9IHN0eWxlIC0gIHN0eWxlIChlaXRoZXIgXCJmaWxsXCIgb3IgXCJzdHJva2VcIilcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciAtIHRoZSBjb2xvciB0byBmaWxsL3N0cm9rZSB3aXRoXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSB0aGUgY2FudmFzIGVsZW1lbnRcbiAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH0gLSB0aGUgY3JlYXRlZCBvZmZzY3JlZW4gY2FudmFzXG4gKi9cblxuXG5TcGFydGljbGVzLnByb3RvdHlwZS5kcmF3T2Zmc2NyZWVuQ2FudmFzID0gZnVuY3Rpb24gKHNoYXBlLCBzdHlsZSwgY29sb3IsIGNhbnZhcykge1xuICByZXR1cm4gdGhpcy5vZmZTY3JlZW5DYW52YXNbc2hhcGVdLmNhbGwodGhpcywgc3R5bGUsIGNvbG9yLCBjYW52YXMpO1xufTtcbi8qKlxuICogb2JqZWN0IG9mIHNoYXBlcyB0byBkcmF3XG4gKi9cblxuXG5TcGFydGljbGVzLnByb3RvdHlwZS5vZmZTY3JlZW5DYW52YXMgPSB7fTtcbi8qKlxuICogY3JlYXRlLCBzZXR1cCBhbmQgcmVuZGVyIGFuIG9mZnNjcmVlbiBjYW52YXMgZm9yIGFcbiAqIENpcmNsZSBQYXJ0aWNsZSBvZiB0aGUgZ2l2ZW4gY29sb3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHlsZSAtICBzdHlsZSAoZWl0aGVyIFwiZmlsbFwiIG9yIFwic3Ryb2tlXCIpXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgLSB0aGUgY29sb3IgdG8gZmlsbC9zdHJva2Ugd2l0aFxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gdGhlIGNhbnZhcyBlbGVtZW50XG4gKiBAcmV0dXJucyB7SFRNTENhbnZhc0VsZW1lbnR9IC0gdGhlIGNyZWF0ZWQgb2Zmc2NyZWVuIGNhbnZhc1xuICovXG5cblNwYXJ0aWNsZXMucHJvdG90eXBlLm9mZlNjcmVlbkNhbnZhcy5jaXJjbGUgPSBmdW5jdGlvbiAoc3R5bGUsIGNvbG9yLCBjYW52YXMpIHtcbiAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIHZhciBzaXplID0gdGhpcy5nZXRPZmZzY3JlZW5DYW52YXNTaXplKCk7XG4gIHZhciBsaW5lU2l6ZSA9IHRoaXMuZ2V0TGluZVNpemUoc2l6ZSk7XG4gIHZhciBnbG93U2l6ZSA9IHRoaXMuZ2V0R2xvd1NpemUoc2l6ZSk7XG4gIHZhciBjYW52YXNTaXplID0gc2l6ZSArIGxpbmVTaXplICogMiArIGdsb3dTaXplO1xuICB2YXIgc2hhcGVTaXplID0gc3R5bGUgPT09IFwic3Ryb2tlXCIgPyBzaXplIC0gbGluZVNpemUgOiBzaXplO1xuICBjYW52YXMud2lkdGggPSBjYW52YXNTaXplO1xuICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZTtcbiAgdGhpcy5yZW5kZXJHbG93KGN0eCwgY29sb3IsIHNpemUpO1xuICB0aGlzLnJlbmRlclN0eWxlKGN0eCwgY29sb3IsIGxpbmVTaXplLCBzdHlsZSk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmVsbGlwc2UoY2FudmFzU2l6ZSAvIDIsIGNhbnZhc1NpemUgLyAyLCBzaGFwZVNpemUgLyAyLCBzaGFwZVNpemUgLyAyLCAwLCAwLCAzNjApO1xuICB0aGlzLnJlbmRlckNvbG9yKGN0eCwgc3R5bGUpO1xuICByZXR1cm4gY2FudmFzO1xufTtcbi8qKlxuICogY3JlYXRlLCBzZXR1cCBhbmQgcmVuZGVyIGFuIG9mZnNjcmVlbiBjYW52YXMgZm9yIGFcbiAqIFNxdWFyZSBQYXJ0aWNsZSBvZiB0aGUgZ2l2ZW4gY29sb3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHlsZSAtICBzdHlsZSAoZWl0aGVyIFwiZmlsbFwiIG9yIFwic3Ryb2tlXCIpXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgLSB0aGUgY29sb3IgdG8gZmlsbC9zdHJva2Ugd2l0aFxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gdGhlIGNhbnZhcyBlbGVtZW50XG4gKiBAcmV0dXJucyB7SFRNTENhbnZhc0VsZW1lbnR9IC0gdGhlIGNyZWF0ZWQgb2Zmc2NyZWVuIGNhbnZhc1xuICovXG5cblxuU3BhcnRpY2xlcy5wcm90b3R5cGUub2ZmU2NyZWVuQ2FudmFzLnNxdWFyZSA9IGZ1bmN0aW9uIChzdHlsZSwgY29sb3IsIGNhbnZhcykge1xuICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgdmFyIHNpemUgPSB0aGlzLmdldE9mZnNjcmVlbkNhbnZhc1NpemUoKTtcbiAgdmFyIGxpbmVTaXplID0gdGhpcy5nZXRMaW5lU2l6ZShzaXplKTtcbiAgdmFyIGdsb3dTaXplID0gdGhpcy5nZXRHbG93U2l6ZShzaXplKTtcbiAgdmFyIGNhbnZhc1NpemUgPSBzaXplICsgbGluZVNpemUgKiAyICsgZ2xvd1NpemU7XG4gIHZhciBzaGFwZVNpemUgPSBzdHlsZSA9PT0gXCJzdHJva2VcIiA/IHNpemUgLSBsaW5lU2l6ZSA6IHNpemU7XG4gIGNhbnZhcy53aWR0aCA9IGNhbnZhc1NpemU7XG4gIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNTaXplO1xuICB0aGlzLnJlbmRlckdsb3coY3R4LCBjb2xvciwgc2l6ZSk7XG4gIHRoaXMucmVuZGVyU3R5bGUoY3R4LCBjb2xvciwgbGluZVNpemUsIHN0eWxlKTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgucmVjdChjYW52YXNTaXplIC8gMiAtIHNoYXBlU2l6ZSAvIDIsIGNhbnZhc1NpemUgLyAyIC0gc2hhcGVTaXplIC8gMiwgc2hhcGVTaXplLCBzaGFwZVNpemUpO1xuICB0aGlzLnJlbmRlckNvbG9yKGN0eCwgc3R5bGUpO1xuICByZXR1cm4gY2FudmFzO1xufTtcbi8qKlxuICogY3JlYXRlLCBzZXR1cCBhbmQgcmVuZGVyIGFuIG9mZnNjcmVlbiBjYW52YXMgZm9yIGFcbiAqIExpbmUvQ3VydmUgUGFydGljbGUgb2YgdGhlIGdpdmVuIGNvbG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gc3R5bGUgLSAgc3R5bGUgKGVpdGhlciBcImZpbGxcIiBvciBcInN0cm9rZVwiKVxuICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIC0gdGhlIGNvbG9yIHRvIGZpbGwvc3Ryb2tlIHdpdGhcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIHRoZSBjYW52YXMgZWxlbWVudFxuICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fSAtIHRoZSBjcmVhdGVkIG9mZnNjcmVlbiBjYW52YXNcbiAqL1xuXG5cblNwYXJ0aWNsZXMucHJvdG90eXBlLm9mZlNjcmVlbkNhbnZhcy5saW5lID0gZnVuY3Rpb24gKHN0eWxlLCBjb2xvciwgY2FudmFzKSB7XG4gIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICB2YXIgc2l6ZSA9IHRoaXMuZ2V0T2Zmc2NyZWVuQ2FudmFzU2l6ZSgpICogMS41O1xuICB2YXIgbGluZVNpemUgPSB0aGlzLmdldExpbmVTaXplKHNpemUpO1xuICB2YXIgZ2xvd1NpemUgPSB0aGlzLmdldEdsb3dTaXplKHNpemUpO1xuICB2YXIgY2FudmFzU2l6ZSA9IHNpemUgKyBsaW5lU2l6ZSAqIDIgKyBnbG93U2l6ZTtcbiAgdmFyIHN0YXJ0eCA9IGNhbnZhc1NpemUgLyAyIC0gc2l6ZSAvIDI7XG4gIHZhciBzdGFydHkgPSBjYW52YXNTaXplIC8gMiAtIHNpemUgLyAyO1xuICBjYW52YXMud2lkdGggPSBjYW52YXNTaXplO1xuICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZTtcbiAgdGhpcy5yZW5kZXJHbG93KGN0eCwgY29sb3IsIHNpemUpO1xuICBjdHgubGluZVdpZHRoID0gbGluZVNpemU7XG4gIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8oc3RhcnR4LCBzdGFydHkpO1xuICBjdHgubGluZVRvKHN0YXJ0eCArIHNpemUsIHN0YXJ0eSArIHNpemUpO1xuICBjdHguc3Ryb2tlKCk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgcmV0dXJuIGNhbnZhcztcbn07XG4vKipcbiAqIGNyZWF0ZSwgc2V0dXAgYW5kIHJlbmRlciBhbiBvZmZzY3JlZW4gY2FudmFzIGZvciBhXG4gKiBUcmlhbmdsZSBQYXJ0aWNsZSBvZiB0aGUgZ2l2ZW4gY29sb3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHlsZSAtICBzdHlsZSAoZWl0aGVyIFwiZmlsbFwiIG9yIFwic3Ryb2tlXCIpXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgLSB0aGUgY29sb3IgdG8gZmlsbC9zdHJva2Ugd2l0aFxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gdGhlIGNhbnZhcyBlbGVtZW50XG4gKiBAcmV0dXJucyB7SFRNTENhbnZhc0VsZW1lbnR9IC0gdGhlIGNyZWF0ZWQgb2Zmc2NyZWVuIGNhbnZhc1xuICovXG5cblxuU3BhcnRpY2xlcy5wcm90b3R5cGUub2ZmU2NyZWVuQ2FudmFzLnRyaWFuZ2xlID0gZnVuY3Rpb24gKHN0eWxlLCBjb2xvciwgY2FudmFzKSB7XG4gIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICB2YXIgc2l6ZSA9IHRoaXMuZ2V0T2Zmc2NyZWVuQ2FudmFzU2l6ZSgpO1xuICB2YXIgbGluZVNpemUgPSB0aGlzLmdldExpbmVTaXplKHNpemUpO1xuICB2YXIgZ2xvd1NpemUgPSB0aGlzLmdldEdsb3dTaXplKHNpemUpO1xuICB2YXIgY2FudmFzU2l6ZSA9IHNpemUgKyBsaW5lU2l6ZSAqIDIgKyBnbG93U2l6ZTtcbiAgdmFyIHNoYXBlU2l6ZSA9IHN0eWxlID09PSBcInN0cm9rZVwiID8gc2l6ZSAtIGxpbmVTaXplIDogc2l6ZTtcbiAgdmFyIGhlaWdodCA9IHNoYXBlU2l6ZSAqIChNYXRoLnNxcnQoMykgLyAyKTtcbiAgdmFyIHN0YXJ0eCA9IGNhbnZhc1NpemUgLyAyO1xuICB2YXIgc3RhcnR5ID0gY2FudmFzU2l6ZSAvIDIgLSBzaGFwZVNpemUgLyAyO1xuICBjYW52YXMud2lkdGggPSBjYW52YXNTaXplO1xuICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZTtcbiAgdGhpcy5yZW5kZXJHbG93KGN0eCwgY29sb3IsIHNpemUpO1xuICB0aGlzLnJlbmRlclN0eWxlKGN0eCwgY29sb3IsIGxpbmVTaXplLCBzdHlsZSk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyhzdGFydHgsIHN0YXJ0eSk7XG4gIGN0eC5saW5lVG8oc3RhcnR4IC0gc2hhcGVTaXplIC8gMiwgc3RhcnR5ICsgaGVpZ2h0KTtcbiAgY3R4LmxpbmVUbyhzdGFydHggKyBzaGFwZVNpemUgLyAyLCBzdGFydHkgKyBoZWlnaHQpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIHRoaXMucmVuZGVyQ29sb3IoY3R4LCBzdHlsZSk7XG4gIHJldHVybiBjYW52YXM7XG59O1xuLyoqXG4gKiBjcmVhdGUsIHNldHVwIGFuZCByZW5kZXIgYW4gb2Zmc2NyZWVuIGNhbnZhcyBmb3IgYVxuICogRGlhbW9uZCBTcGFya2xlIFBhcnRpY2xlIG9mIHRoZSBnaXZlbiBjb2xvclxuICogQHBhcmFtIHtTdHJpbmd9IHN0eWxlIC0gIHN0eWxlIChlaXRoZXIgXCJmaWxsXCIgb3IgXCJzdHJva2VcIilcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciAtIHRoZSBjb2xvciB0byBmaWxsL3N0cm9rZSB3aXRoXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSB0aGUgY2FudmFzIGVsZW1lbnRcbiAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH0gLSB0aGUgY3JlYXRlZCBvZmZzY3JlZW4gY2FudmFzXG4gKi9cblxuXG5TcGFydGljbGVzLnByb3RvdHlwZS5vZmZTY3JlZW5DYW52YXMuZGlhbW9uZCA9IGZ1bmN0aW9uIChzdHlsZSwgY29sb3IsIGNhbnZhcykge1xuICB2YXIgcGF0aFNpemUgPSAxMDA7XG4gIHZhciBwYXRoID0gbmV3IFBhdGgyRChcIk00Myw4My43NCw0OC42Myw5OWExLjQ2LDEuNDYsMCwwLDAsMi43NCwwTDU3LDgzLjc0QTQ1LjA5LDQ1LjA5LDAsMCwxLDgzLjc0LDU3TDk5LDUxLjM3YTEuNDYsMS40NiwwLDAsMCwwLTIuNzRMODMuNzQsNDNBNDUuMTEsNDUuMTEsMCwwLDEsNTcsMTYuMjZMNTEuMzcsMWExLjQ2LDEuNDYsMCwwLDAtMi43NCwwTDQzLDE2LjI2QTQ1LjExLDQ1LjExLDAsMCwxLDE2LjI2LDQzTDEsNDguNjNhMS40NiwxLjQ2LDAsMCwwLDAsMi43NEwxNi4yNiw1N0E0NS4wOSw0NS4wOSwwLDAsMSw0Myw4My43NFpcIik7XG4gIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICB2YXIgc2l6ZSA9IHRoaXMuZ2V0T2Zmc2NyZWVuQ2FudmFzU2l6ZSgpO1xuICB2YXIgbGluZVNpemUgPSB0aGlzLmdldExpbmVTaXplKHNpemUpO1xuICB2YXIgZ2xvd1NpemUgPSB0aGlzLmdldEdsb3dTaXplKHNpemUpO1xuICB2YXIgY2FudmFzU2l6ZSA9IHNpemUgKyBsaW5lU2l6ZSAqIDIgKyBnbG93U2l6ZTtcbiAgdmFyIHNjYWxlID0gY2FudmFzU2l6ZSAvICgocGF0aFNpemUgKyBnbG93U2l6ZSkgKiAxLjEpO1xuICBjYW52YXMud2lkdGggPSBjYW52YXNTaXplO1xuICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZTtcbiAgdGhpcy5yZW5kZXJHbG93KGN0eCwgY29sb3IsIHNpemUpO1xuICB0aGlzLnJlbmRlclN0eWxlKGN0eCwgY29sb3IsIGxpbmVTaXplIC8gc2NhbGUsIHN0eWxlKTtcbiAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gIGN0eC50cmFuc2xhdGUocGF0aFNpemUgKiAwLjA1ICsgZ2xvd1NpemUgKiAwLjUsIHBhdGhTaXplICogMC4wNSArIGdsb3dTaXplICogMC41KTtcbiAgdGhpcy5yZW5kZXJDb2xvcihjdHgsIHN0eWxlLCBwYXRoKTtcbiAgcmV0dXJuIGNhbnZhcztcbn07XG4vKipcbiAqIGNyZWF0ZSwgc2V0dXAgYW5kIHJlbmRlciBhbiBvZmZzY3JlZW4gY2FudmFzIGZvciBhXG4gKiBTdGFyIFBhcnRpY2xlIG9mIHRoZSBnaXZlbiBjb2xvclxuICogQHBhcmFtIHtTdHJpbmd9IHN0eWxlIC0gIHN0eWxlIChlaXRoZXIgXCJmaWxsXCIgb3IgXCJzdHJva2VcIilcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciAtIHRoZSBjb2xvciB0byBmaWxsL3N0cm9rZSB3aXRoXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSB0aGUgY2FudmFzIGVsZW1lbnRcbiAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH0gLSB0aGUgY3JlYXRlZCBvZmZzY3JlZW4gY2FudmFzXG4gKi9cblxuXG5TcGFydGljbGVzLnByb3RvdHlwZS5vZmZTY3JlZW5DYW52YXMuc3RhciA9IGZ1bmN0aW9uIChzdHlsZSwgY29sb3IsIGNhbnZhcykge1xuICB2YXIgcGF0aFNpemUgPSAxMDA7XG4gIHZhciBwYXRoID0gbmV3IFBhdGgyRChcIk05OS44NiwzNi40NWEyLjk0LDIuOTQsMCwwLDAtMi4zNy0ybC0zMS00LjU0TDUyLjYzLDEuNjRhMi45MywyLjkzLDAsMCwwLTUuMjYsMEwzMy41MSwyOS45MWwtMzEsNC41NGEzLDMsMCwwLDAtMi4zNywyLDMsMywwLDAsMCwuNzQsM2wyMi40NCwyMkwxOCw5Mi41NUEyLjk0LDIuOTQsMCwwLDAsMjAuOTEsOTZhMi44NiwyLjg2LDAsMCwwLDEuMzYtLjM0TDUwLDgxLDc3LjczLDk1LjY2YTIuOTEsMi45MSwwLDAsMCwzLjA4LS4yMkEzLDMsMCwwLDAsODIsOTIuNTVsLTUuMy0zMS4wNywyMi40NC0yMkEzLDMsMCwwLDAsOTkuODYsMzYuNDVaXCIpO1xuICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgdmFyIHNpemUgPSB0aGlzLmdldE9mZnNjcmVlbkNhbnZhc1NpemUoKTtcbiAgdmFyIGxpbmVTaXplID0gdGhpcy5nZXRMaW5lU2l6ZShzaXplKTtcbiAgdmFyIGdsb3dTaXplID0gdGhpcy5nZXRHbG93U2l6ZShzaXplKTtcbiAgdmFyIGNhbnZhc1NpemUgPSBzaXplICsgbGluZVNpemUgKiAyICsgZ2xvd1NpemU7XG4gIHZhciBzY2FsZSA9IGNhbnZhc1NpemUgLyAoKHBhdGhTaXplICsgZ2xvd1NpemUpICogMS4xKTtcbiAgY2FudmFzLndpZHRoID0gY2FudmFzU2l6ZTtcbiAgY2FudmFzLmhlaWdodCA9IGNhbnZhc1NpemU7XG4gIGN0eC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICB0aGlzLnJlbmRlckdsb3coY3R4LCBjb2xvciwgc2l6ZSk7XG4gIHRoaXMucmVuZGVyU3R5bGUoY3R4LCBjb2xvciwgbGluZVNpemUgLyBzY2FsZSwgc3R5bGUpO1xuICBjdHgudHJhbnNsYXRlKHBhdGhTaXplICogMC4wNSArIGdsb3dTaXplICogMC41LCBwYXRoU2l6ZSAqIDAuMDUgKyBnbG93U2l6ZSAqIDAuNSk7XG4gIHRoaXMucmVuZGVyQ29sb3IoY3R4LCBzdHlsZSwgcGF0aCk7XG4gIHJldHVybiBjYW52YXM7XG59O1xuLyoqXG4gKiBjcmVhdGUsIHNldHVwIGFuZCByZW5kZXIgYW4gb2Zmc2NyZWVuIGNhbnZhcyBmb3IgYVxuICogQ3VzdG9tIEltYWdlIFBhcnRpY2xlIG9mIHRoZSBnaXZlbiBjb2xvclxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWFnZSAtIHRoZSBpbWFnZSBlbGVtZW50IHRoYXQgaGFzIGxvYWRlZFxuICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIC0gdGhlIGNvbG9yIHRvIGZpbGwvc3Ryb2tlIHdpdGhcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIHRoZSBjYW52YXMgZWxlbWVudFxuICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fSAtIHRoZSBjcmVhdGVkIG9mZnNjcmVlbiBjYW52YXNcbiAqL1xuXG5cblNwYXJ0aWNsZXMucHJvdG90eXBlLmRyYXdPZmZzY3JlZW5DYW52YXNGb3JJbWFnZSA9IGZ1bmN0aW9uIChpbWFnZSwgY29sb3IsIGNhbnZhcykge1xuICB2YXIgc2l6ZSA9IGltYWdlLndpZHRoO1xuICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgY2FudmFzLndpZHRoID0gc2l6ZTtcbiAgY2FudmFzLmhlaWdodCA9IHNpemU7XG4gIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHNpemUsIHNpemUsIDAsIDAsIHNpemUsIHNpemUpO1xuICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2UtYXRvcFwiO1xuICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gIGN0eC5maWxsUmVjdCgwLCAwLCBzaXplLCBzaXplKTtcbiAgcmV0dXJuIGNhbnZhcztcbn07XG4vKipcbiAqIC0gd2lwZSB0aGUgY2FudmFzLFxuICogLSB1cGRhdGUgZWFjaCBzcGFydGljbGUsXG4gKiAtIHJlbmRlciBlYWNoIHNwYXJ0aWNsZVxuICogLSBzb3J0IHNvIHRoYXQgbGFyZ2VyIHBhcnRpY2xlcyBvbiB0b3BcbiAqIEByZXR1cm5zIHtBcnJheX0gdGhlIGFycmF5IG9mIFNwYXJ0aWNsZSBpbnN0YW5jZXNcbiAqL1xuXG5cblNwYXJ0aWNsZXMucHJvdG90eXBlLmRyYXdGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3BhcnRpY2xlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzcGFydGljbGUgPSB0aGlzLnNwYXJ0aWNsZXNbaV07XG4gICAgc3BhcnRpY2xlLnVwZGF0ZSgpLnJlbmRlcih0aGlzLmNhbnZhc3Nlcyk7XG4gIH1cblxuICB0aGlzLnNvcnQoKTtcbiAgcmV0dXJuIHRoaXMuc3BhcnRpY2xlcztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNwYXJ0aWNsZXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/sparticles@1.3.1/node_modules/sparticles/dist/sparticles.mjs\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/css/app.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;